{"name": " get_historical_rate", "description": "\u041f\u043e\u043b\u0443\u0447\u0435\u043d\u0438\u0435 \u0438\u0441\u0442\u043e\u0440\u0438\u0447\u0435\u0441\u043a\u043e\u0433\u043e \u043a\u0443\u0440\u0441\u0430 \u0432\u0430\u043b\u044e\u0442. \u0423\u043a\u0430\u0437\u044b\u0432\u0430\u0435\u0442\u0441\u044f base_currency \u0434\u043b\u044f \u0442\u043e\u0439 \u0432\u0430\u043b\u044e\u0442\u044b, \u0438\u0437 \u043a\u043e\u0442\u043e\u0440\u043e\u0439 \u043d\u0443\u0436\u043d\u043e \u0441\u0434\u0435\u043b\u0430\u0442\u044c \u043f\u0435\u0440\u0435\u0432\u043e\u0434, target_currency \u0434\u043b\u044f \u0442\u043e\u0439 \u0432\u0430\u043b\u044e\u0442\u044b, \u0432 \u043a\u043e\u0442\u043e\u0440\u0443\u044e \u043d\u0443\u0436\u043d\u043e \u043f\u0435\u0440\u0435\u0432\u0435\u0441\u0442\u0438, month \u0432 \u0432\u0438\u0434\u0435 \u0447\u0438\u0441\u043b\u0430 \u043e\u0442 1 \u0434\u043e 12, day \u0432 \u0432\u0438\u0434\u0435 \u0447\u0438\u0441\u043b\u0430 \u043e\u0442 1 \u0434\u043e 31, year \u0432 \u0432\u0438\u0434\u0435 \u0447\u0438\u0441\u043b\u0430", "icon": null, "icon_bg_color": null, "gradient": null, "data": {"nodes": [{"id": "GetLatestRate-xeIPj", "type": "genericNode", "position": {"x": -795.6720541308147, "y": 793.1112751229653}, "data": {"id": "GetLatestRate-xeIPj", "node": {"template": {"_type": "Component", "amount": {"tool_mode": true, "trace_as_input": true, "trace_as_metadata": true, "load_from_db": false, "list": false, "list_add_label": "Add More", "required": false, "placeholder": "", "show": true, "name": "amount", "value": "1", "display_name": "Amount", "advanced": false, "input_types": ["Message"], "dynamic": false, "info": "\u041a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u0432\u0430\u043b\u044e\u0442\u044b, \u043a\u043e\u0442\u043e\u0440\u043e\u0435 \u043d\u0435\u043e\u0431\u0445\u043e\u0434\u0438\u043c\u043e \u043a\u043e\u043d\u0432\u0435\u0440\u0442\u0438\u0440\u043e\u0432\u0430\u0442\u044c, float. \u041d\u0435 \u044f\u0432\u043b\u044f\u0435\u0442\u0441\u044f \u043e\u0431\u044f\u0437\u0430\u0442\u0435\u043b\u044c\u043d\u044b\u043c \u043f\u043e\u043b\u0435\u043c", "title_case": false, "type": "str", "_input_type": "MessageTextInput"}, "base_currency": {"tool_mode": true, "trace_as_input": true, "trace_as_metadata": true, "load_from_db": false, "list": false, "list_add_label": "Add More", "required": true, "placeholder": "", "show": true, "name": "base_currency", "value": "", "display_name": "Base Currency", "advanced": false, "input_types": ["Message"], "dynamic": false, "info": "ISO 4217 \u043a\u043e\u0434, \u043d\u0430\u043f\u0440\u0438\u043c\u0435\u0440, USD. \u0411\u0430\u0437\u043e\u0432\u0430\u044f \u0432\u0430\u043b\u044e\u0442\u0430, \u0438\u0437 \u043a\u043e\u0442\u043e\u0440\u043e\u0439 \u043d\u0443\u0436\u043d\u043e \u043f\u043e\u043b\u0443\u0447\u0438\u0442\u044c \u043a\u043e\u043d\u0432\u0435\u0440\u0442\u0430\u0446\u0438\u044e", "title_case": false, "type": "str", "_input_type": "MessageTextInput"}, "code": {"type": "code", "required": true, "placeholder": "", "list": false, "show": true, "multiline": true, "value": "# from langflow.field_typing import Data\nfrom langflow.custom.custom_component.component import Component\nfrom langflow.io import MessageTextInput, Output\nfrom langflow.schema.data import Data\n\n\nclass GetLatestRate(Component):\n    display_name = \"Get Latest Rate input\"\n    description = \"Base currency to the target currency\"\n    icon = \"dollar-sign\"\n    name = \"GetLatestRate\"\n\n    inputs = [\n        MessageTextInput(\n            name=\"year\",\n            display_name=\"year\",\n            info=\"\u0433\u043e\u0434 \u0434\u043b\u044f \u043f\u043e\u043b\u0443\u0447\u0435\u043d\u0438\u044f \u043a\u0443\u0440\u0441\u0430 \u0432\u0430\u043b\u044e\u0442\u044b\",\n            value=\"2025\",\n            tool_mode=True,\n            required=True\n        ),\n        MessageTextInput(\n            name=\"month\",\n            display_name=\"month\",\n            info=\"\u043c\u0435\u0441\u044f\u0446 \u0434\u043b\u044f \u043f\u043e\u043b\u0443\u0447\u0435\u043d\u0438\u044f \u043a\u0443\u0440\u0441\u0430 \u0432\u0430\u043b\u044e\u0442\u044b\",\n            value=\"02\",\n            tool_mode=True,\n            required=True\n        ),\n        MessageTextInput(\n            name=\"day\",\n            display_name=\"day\",\n            info=\"\u0434\u0435\u043d\u044c \u0434\u043b\u044f \u043f\u043e\u043b\u0443\u0447\u0435\u043d\u0438\u044f \u043a\u0443\u0440\u0441\u0430 \u0432\u0430\u043b\u044e\u0442\u044b\",\n            value=\"10\",\n            tool_mode=True,\n            required=True\n        ),\n        MessageTextInput(\n            name=\"base_currency\",\n            display_name=\"Base Currency\",\n            info=\"ISO 4217 \u043a\u043e\u0434, \u043d\u0430\u043f\u0440\u0438\u043c\u0435\u0440, USD. \u0411\u0430\u0437\u043e\u0432\u0430\u044f \u0432\u0430\u043b\u044e\u0442\u0430, \u0438\u0437 \u043a\u043e\u0442\u043e\u0440\u043e\u0439 \u043d\u0443\u0436\u043d\u043e \u043f\u043e\u043b\u0443\u0447\u0438\u0442\u044c \u043a\u043e\u043d\u0432\u0435\u0440\u0442\u0430\u0446\u0438\u044e\",\n            value=\"USD\",\n            tool_mode=True, \n            required=True\n        ),\n        MessageTextInput(\n            name=\"target_currency\",\n            display_name=\"Target Currency\",\n            info=\"ISO 4217 \u043a\u043e\u0434, \u043d\u0430\u043f\u0440\u0438\u043c\u0435\u0440, RUB. \u0426\u0435\u043b\u0435\u0432\u0430\u044f \u0432\u0430\u043b\u044e\u0442\u0430, \u0432 \u043a\u043e\u0442\u043e\u0440\u0443\u044e \u043d\u0443\u0436\u043d\u043e \u043f\u043e\u043b\u0443\u0447\u0438\u0442\u044c \u043a\u043e\u043d\u0432\u0435\u0440\u0442\u0430\u0446\u0438\u044e\",\n            value=\"RUB\",\n            tool_mode=True,\n            required=True\n        ),\n        MessageTextInput(\n            name=\"amount\",\n            display_name=\"Amount\",\n            info=\"\u041a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u0432\u0430\u043b\u044e\u0442\u044b, \u043a\u043e\u0442\u043e\u0440\u043e\u0435 \u043d\u0435\u043e\u0431\u0445\u043e\u0434\u0438\u043c\u043e \u043a\u043e\u043d\u0432\u0435\u0440\u0442\u0438\u0440\u043e\u0432\u0430\u0442\u044c, float. \u041d\u0435 \u044f\u0432\u043b\u044f\u0435\u0442\u0441\u044f \u043e\u0431\u044f\u0437\u0430\u0442\u0435\u043b\u044c\u043d\u044b\u043c \u043f\u043e\u043b\u0435\u043c\",\n            value=\"1.0\",\n            tool_mode=True,\n            required=False\n        ),\n    ]\n\n    outputs = [\n        Output(name=\"params\", display_name=\"Parameters\", method=\"build_params\")\n    ]\n\n    def build_params(self) -> Data:\n        try:\n            float_amount = float(self.amount)\n        except ValueError:\n            float_amount = 1.0\n        return Data(data={\n            \"base\": self.base_currency,\n            \"year\": self.year,\n            \"month\": self.month,\n            \"day\": self.day,\n            \"base\": self.base_currency,\n            \"target\": self.target_currency,\n            \"amount\": float_amount\n        })\n", "fileTypes": [], "file_path": "", "password": false, "name": "code", "advanced": true, "dynamic": true, "info": "", "load_from_db": false, "title_case": false}, "day": {"tool_mode": true, "trace_as_input": true, "trace_as_metadata": true, "load_from_db": false, "list": false, "list_add_label": "Add More", "required": true, "placeholder": "", "show": true, "name": "day", "value": "10", "display_name": "day", "advanced": false, "input_types": ["Message"], "dynamic": false, "info": "\u0434\u0435\u043d\u044c \u0434\u043b\u044f \u043f\u043e\u043b\u0443\u0447\u0435\u043d\u0438\u044f \u043a\u0443\u0440\u0441\u0430 \u0432\u0430\u043b\u044e\u0442\u044b", "title_case": false, "type": "str", "_input_type": "MessageTextInput"}, "month": {"tool_mode": true, "trace_as_input": true, "trace_as_metadata": true, "load_from_db": false, "list": false, "list_add_label": "Add More", "required": true, "placeholder": "", "show": true, "name": "month", "value": "01", "display_name": "month", "advanced": false, "input_types": ["Message"], "dynamic": false, "info": "\u043c\u0435\u0441\u044f\u0446 \u0434\u043b\u044f \u043f\u043e\u043b\u0443\u0447\u0435\u043d\u0438\u044f \u043a\u0443\u0440\u0441\u0430 \u0432\u0430\u043b\u044e\u0442\u044b", "title_case": false, "type": "str", "_input_type": "MessageTextInput"}, "target_currency": {"tool_mode": true, "trace_as_input": true, "trace_as_metadata": true, "load_from_db": false, "list": false, "list_add_label": "Add More", "required": true, "placeholder": "", "show": true, "name": "target_currency", "value": "RUB", "display_name": "Target Currency", "advanced": false, "input_types": ["Message"], "dynamic": false, "info": "ISO 4217 \u043a\u043e\u0434, \u043d\u0430\u043f\u0440\u0438\u043c\u0435\u0440, RUB. \u0426\u0435\u043b\u0435\u0432\u0430\u044f \u0432\u0430\u043b\u044e\u0442\u0430, \u0432 \u043a\u043e\u0442\u043e\u0440\u0443\u044e \u043d\u0443\u0436\u043d\u043e \u043f\u043e\u043b\u0443\u0447\u0438\u0442\u044c \u043a\u043e\u043d\u0432\u0435\u0440\u0442\u0430\u0446\u0438\u044e", "title_case": false, "type": "str", "_input_type": "MessageTextInput"}, "year": {"tool_mode": true, "trace_as_input": true, "trace_as_metadata": true, "load_from_db": false, "list": false, "list_add_label": "Add More", "required": true, "placeholder": "", "show": true, "name": "year", "value": "2013", "display_name": "year", "advanced": false, "input_types": ["Message"], "dynamic": false, "info": "\u0433\u043e\u0434 \u0434\u043b\u044f \u043f\u043e\u043b\u0443\u0447\u0435\u043d\u0438\u044f \u043a\u0443\u0440\u0441\u0430 \u0432\u0430\u043b\u044e\u0442\u044b", "title_case": false, "type": "str", "_input_type": "MessageTextInput"}}, "description": "Base currency to the target currency", "icon": "dollar-sign", "base_classes": ["Data"], "display_name": "Get Latest Rate input", "documentation": "", "minimized": false, "custom_fields": {}, "output_types": [], "pinned": false, "conditional_paths": [], "frozen": false, "outputs": [{"types": ["Data"], "selected": "Data", "name": "params", "hidden": null, "display_name": "Parameters", "method": "build_params", "value": "__UNDEFINED__", "cache": true, "required_inputs": null, "allows_loop": false, "group_outputs": false, "options": null, "tool_mode": true}], "field_order": ["year", "month", "day", "base_currency", "target_currency", "amount"], "beta": false, "legacy": false, "edited": true, "metadata": {}, "tool_mode": false, "lf_version": "1.6.3"}, "showNode": true, "type": "GetLatestRate"}, "selected": false, "measured": {"width": 320, "height": 613}, "dragging": false}, {"id": "CustomComponent-UuzJ9", "type": "genericNode", "position": {"x": 2049.920853465756, "y": 943.6067778976092}, "data": {"node": {"template": {"_type": "Component", "amount": {"tool_mode": false, "trace_as_input": true, "trace_as_metadata": true, "load_from_db": false, "list": false, "list_add_label": "Add More", "required": false, "placeholder": "", "show": true, "name": "amount", "value": "", "display_name": "Amount", "advanced": false, "input_types": ["Message"], "dynamic": false, "info": "", "title_case": false, "type": "str", "_input_type": "MessageTextInput"}, "base_currency": {"tool_mode": false, "trace_as_input": true, "trace_as_metadata": true, "load_from_db": false, "list": false, "list_add_label": "Add More", "required": false, "placeholder": "", "show": true, "name": "base_currency", "value": "", "display_name": "Base ISO (e.g., EUR)", "advanced": false, "input_types": ["Message"], "dynamic": false, "info": "", "title_case": false, "type": "str", "_input_type": "MessageTextInput"}, "code": {"type": "code", "required": true, "placeholder": "", "list": false, "show": true, "multiline": true, "value": "from __future__ import annotations\r\nfrom typing import Any, Dict, Optional\r\nimport requests\r\nfrom datetime import date, timedelta, datetime\r\n\r\nfrom langflow.custom import Component\r\nfrom langflow.io import (\r\n    StrInput,\r\n    IntInput,\r\n    FloatInput,\r\n    BoolInput,\r\n    MessageTextInput,\r\n    Output,\r\n)\r\nfrom langflow.schema import Data\r\nimport xml.etree.ElementTree as ET\r\n\r\n\r\ndef _to_float(x: Optional[str | float | int]) -> Optional[float]:\r\n    if x is None:\r\n        return None\r\n    try:\r\n        return float(str(x).replace(\",\", \".\").strip())\r\n    except Exception:\r\n        return None\r\n\r\n\r\nclass CBRHistoricalConverter(Component):\r\n    display_name = \"CBR GetCursOnDate Converter\"\r\n    description = \"\u041a\u0443\u0440\u0441 \u0426\u0411 \u0420\u0424 \u043d\u0430 \u0434\u0430\u0442\u0443 \u0438 \u043a\u043e\u043d\u0432\u0435\u0440\u0442\u0430\u0446\u0438\u044f base\u2192target \u0447\u0435\u0440\u0435\u0437 \u043a\u0440\u043e\u0441\u0441\u2011\u043a\u0443\u0440\u0441.\"\r\n    documentation = \"https://www.cbr.ru/development/dws/\"\r\n    icon = \"Currencies\"\r\n\r\n    inputs = [\r\n        StrInput(name=\"if_else_input\", display_name=\"If-else input\", input_types=[\"str\", \"Message\"]),\r\n        MessageTextInput(name=\"day\", display_name=\"Day\", value=\"10\"),\r\n        MessageTextInput(name=\"month\", display_name=\"Month\", value=\"1\"),\r\n        MessageTextInput(name=\"year\", display_name=\"Year\", value=\"2025\"),\r\n        MessageTextInput(name=\"base_currency\", display_name=\"Base ISO (e.g., EUR)\", value=\"EUR\"),\r\n        MessageTextInput(name=\"target_currency\", display_name=\"Target ISO (e.g., USD)\", value=\"RUB\"),\r\n        MessageTextInput(name=\"amount\", display_name=\"Amount\", value=\"1.0\"),\r\n        BoolInput(name=\"fallback_previous\", display_name=\"Fallback previous day\", value=True),\r\n        IntInput(name=\"fallback_days\", display_name=\"Max fallback days\", value=7),\r\n        FloatInput(name=\"timeout_sec\", display_name=\"Timeout (s)\", value=30.0),\r\n    ]\r\n\r\n    outputs = [\r\n        Output(display_name=\"Result\", name=\"output\", method=\"build_output\", type=\"Data\"),\r\n    ]\r\n\r\n    def _log(self, msg: str, name: str = \"CBR-LOG\"):\r\n        try:\r\n            self.log(msg, name)\r\n        except Exception:\r\n            pass\r\n\r\n    # JSON \u0430\u0440\u0445\u0438\u0432 cbr-xml-daily: YYYY/MM/DD/daily_json.js\r\n    def _json_get_curs_on_date(self, when: date, timeout: float) -> Dict[str, Dict[str, Any]]:\r\n        y, m, d = when.year, when.month, when.day\r\n        url = f\"https://www.cbr-xml-daily.ru/archive/{y:04d}/{m:02d}/{d:02d}/daily_json.js\"\r\n        try:\r\n            self._log(f\"GET {url} timeout={timeout}s\")\r\n            r = requests.get(url, timeout=timeout)\r\n            self._log(f\"HTTP {r.status_code} CT={r.headers.get('Content-Type')}\")\r\n            if r.status_code != 200:\r\n                return {}\r\n            js = r.json()\r\n        except Exception as e:\r\n            self._log(f\"JSON fetch/parse error: {e}\")\r\n            return {}\r\n        val = js.get(\"Valute\") or {}\r\n        rows: Dict[str, Dict[str, Any]] = {}\r\n        for code, rec in val.items():\r\n            nominal = _to_float(rec.get(\"Nominal\")) or 1.0\r\n            value = _to_float(rec.get(\"Value\"))\r\n            unit = (value / nominal) if (value is not None and nominal) else None\r\n            if code and unit:\r\n                rows[str(code).upper()] = {\r\n                    \"name\": rec.get(\"Name\") or \"\",\r\n                    \"nominal\": nominal,\r\n                    \"rate_per_nominal\": value,\r\n                    \"rate_per_unit\": unit,\r\n                }\r\n        self._log(f\"Collected {len(rows)} codes (JSON); sample={list(rows.keys())[:8]}\")\r\n        return rows\r\n\r\n    # \u041e\u0444\u0438\u0446\u0438\u0430\u043b\u044c\u043d\u044b\u0439 XML \u0434\u043d\u0435\u0432\u043d\u043e\u0439 \u043a\u0443\u0440\u0441: XML_daily.asp?date_req=DD/MM/YYYY\r\n    def _xml_get_curs_on_date(self, when: date, timeout: float) -> Dict[str, Dict[str, Any]]:\r\n        url = \"https://www.cbr.ru/scripts/XML_daily.asp\"\r\n        params = {\"date_req\": when.strftime(\"%d/%m/%Y\")}\r\n        try:\r\n            self._log(f\"GET {url} params={params} timeout={timeout}s\")\r\n            r = requests.get(url, params=params, timeout=timeout)\r\n            self._log(f\"HTTP {r.status_code} CT={r.headers.get('Content-Type')}\")\r\n            if r.status_code != 200:\r\n                return {}\r\n            root = ET.fromstring(r.content)\r\n        except Exception as e:\r\n            self._log(f\"XML fetch/parse error: {e}\")\r\n            return {}\r\n\r\n        rows: Dict[str, Dict[str, Any]] = {}\r\n        for v in root.findall(\"Valute\"):\r\n            code_el = v.find(\"CharCode\")\r\n            name_el = v.find(\"Name\")\r\n            nominal_el = v.find(\"Nominal\")\r\n            value_el = v.find(\"Value\")\r\n            if code_el is None or value_el is None or nominal_el is None:\r\n                continue\r\n            code = (code_el.text or \"\").strip().upper()\r\n            nominal = _to_float(nominal_el.text) or 1.0\r\n            value = _to_float(value_el.text)\r\n            unit = (value / nominal) if (value is not None and nominal) else None\r\n            if code and unit:\r\n                rows[code] = {\r\n                    \"name\": (name_el.text or \"\") if name_el is not None else \"\",\r\n                    \"nominal\": nominal,\r\n                    \"rate_per_nominal\": value,\r\n                    \"rate_per_unit\": unit,\r\n                }\r\n        self._log(f\"Collected {len(rows)} codes (XML); sample={list(rows.keys())[:8]}\")\r\n        return rows\r\n\r\n    def _find_unit_rate_rub(self, mapping: Dict[str, Dict[str, Any]], iso_code: str) -> Optional[float]:\r\n        iso = iso_code.strip().upper()\r\n        if iso == \"RUB\":\r\n            return 1.0\r\n        row = mapping.get(iso)\r\n        return None if row is None else row.get(\"rate_per_unit\")\r\n\r\n    def _should_use_xml(self, dt: date) -> bool:\r\n        today = date.today()\r\n        month_ago = today - timedelta(days=31)\r\n        return dt > month_ago\r\n\r\n    def _get_mapping(self, dt: date, timeout: float) -> tuple[Dict[str, Dict[str, Any]], str]:\r\n        return self._xml_get_curs_on_date(dt, timeout), \"cbr:XML_daily.asp\"\r\n        # \u0440\u0430\u043d\u044c\u0448\u0435 \u0434\u043e\u043b\u0436\u0435\u043d \u0431\u044b\u043b \u0432\u044b\u0431\u0438\u0440\u0430\u0442\u044c, \u0441\u0435\u0439\u0447\u0430\u0441 \u0432\u0441\u0435\u0433\u0434\u0430 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0435\u0442 xml\r\n        # if self._should_use_xml(dt):\r\n        #     return self._xml_get_curs_on_date(dt, timeout), \"cbr:XML_daily.asp\"\r\n        # else:\r\n        #     return self._json_get_curs_on_date(dt, timeout), \"cbr-xml-daily:daily_json.js\"\r\n\r\n    def build_output(self) -> Data:\r\n        # read inputs\r\n        y, m, d = int(self.year), int(self.month), int(self.day)\r\n        base = (self.base_currency or \"EUR\").strip().upper()\r\n        target = (self.target_currency or \"RUB\").strip().upper()\r\n        amount = float(self.amount or 1.0)\r\n        timeout = float(self.timeout_sec or 30.0)\r\n        max_back = max(0, int(self.fallback_days or 0))\r\n        use_back = bool(self.fallback_previous)\r\n\r\n        when = date(y, m, d)\r\n        matched = when\r\n\r\n        mapping, source = self._get_mapping(when, timeout)\r\n\r\n        # fallback to previous available day if not found\r\n        steps = 0\r\n        while (base != \"RUB\" and base not in mapping) or (target != \"RUB\" and target not in mapping):\r\n            if not use_back or steps >= max_back:\r\n                break\r\n            matched = matched - timedelta(days=1)\r\n            self._log(f\"Fallback step {steps+1} \u2192 {matched.isoformat()}\")\r\n            mapping, source = self._get_mapping(matched, timeout)\r\n            steps += 1\r\n\r\n        base_rub = self._find_unit_rate_rub(mapping, base)\r\n        target_rub = self._find_unit_rate_rub(mapping, target)\r\n\r\n        if base_rub is None or target_rub is None:\r\n            return Data(\r\n                data={\r\n                    \"error\": \"rate_not_found\",\r\n                    \"date_requested\": when.isoformat(),\r\n                    \"matched_date\": matched.isoformat(),\r\n                    \"base\": base,\r\n                    \"target\": target,\r\n                    \"have_base\": base in mapping or base == \"RUB\",\r\n                    \"have_target\": target in mapping or target == \"RUB\",\r\n                    \"codes\": list(mapping.keys()),\r\n                },\r\n                text=f\"Cannot find rates for {base}->{target} on {when} (matched {matched})\",\r\n            )\r\n\r\n        rate = base_rub / target_rub  # target per 1 base\r\n        converted = amount * rate\r\n\r\n        return Data(\r\n            data={\r\n                \"date_requested\": when.isoformat(),\r\n                \"matched_date\": matched.isoformat(),\r\n                \"base\": base,\r\n                \"target\": target,\r\n                \"amount\": amount,\r\n                \"rate\": rate,\r\n                \"converted_amount\": converted,\r\n                \"source\": source,\r\n            },\r\n            text=f\"{amount:.2f} {base} = {converted:.4f} {target} (rate {rate:.6f} on {matched})\",\r\n        )\r\n", "fileTypes": [], "file_path": "", "password": false, "name": "code", "advanced": true, "dynamic": true, "info": "", "load_from_db": false, "title_case": false}, "day": {"tool_mode": false, "trace_as_input": true, "trace_as_metadata": true, "load_from_db": false, "list": false, "list_add_label": "Add More", "required": false, "placeholder": "", "show": true, "name": "day", "value": "", "display_name": "Day", "advanced": false, "input_types": ["Message"], "dynamic": false, "info": "", "title_case": false, "type": "str", "_input_type": "MessageTextInput"}, "fallback_days": {"tool_mode": false, "trace_as_metadata": true, "list": false, "list_add_label": "Add More", "required": false, "placeholder": "", "show": true, "name": "fallback_days", "value": 30, "display_name": "Max fallback days", "advanced": false, "dynamic": false, "info": "", "title_case": false, "type": "int", "_input_type": "IntInput", "load_from_db": false}, "fallback_previous": {"tool_mode": false, "trace_as_metadata": true, "list": false, "list_add_label": "Add More", "required": false, "placeholder": "", "show": true, "name": "fallback_previous", "value": true, "display_name": "Fallback previous day", "advanced": false, "dynamic": false, "info": "", "title_case": false, "type": "bool", "_input_type": "BoolInput"}, "if_else_input": {"tool_mode": false, "trace_as_metadata": true, "load_from_db": false, "list": false, "list_add_label": "Add More", "required": false, "placeholder": "", "show": true, "name": "if_else_input", "value": "", "display_name": "If-else input", "advanced": false, "input_types": ["str", "Message"], "dynamic": false, "info": "", "title_case": false, "type": "str", "_input_type": "StrInput"}, "month": {"tool_mode": false, "trace_as_input": true, "trace_as_metadata": true, "load_from_db": false, "list": false, "list_add_label": "Add More", "required": false, "placeholder": "", "show": true, "name": "month", "value": "", "display_name": "Month", "advanced": false, "input_types": ["Message"], "dynamic": false, "info": "", "title_case": false, "type": "str", "_input_type": "MessageTextInput"}, "target_currency": {"tool_mode": false, "trace_as_input": true, "trace_as_metadata": true, "load_from_db": false, "list": false, "list_add_label": "Add More", "required": false, "placeholder": "", "show": true, "name": "target_currency", "value": "", "display_name": "Target ISO (e.g., USD)", "advanced": false, "input_types": ["Message"], "dynamic": false, "info": "", "title_case": false, "type": "str", "_input_type": "MessageTextInput"}, "timeout_sec": {"tool_mode": false, "trace_as_metadata": true, "list": false, "list_add_label": "Add More", "required": false, "placeholder": "", "show": true, "name": "timeout_sec", "value": 30, "display_name": "Timeout (s)", "advanced": false, "dynamic": false, "info": "", "title_case": false, "type": "float", "_input_type": "FloatInput"}, "year": {"tool_mode": false, "trace_as_input": true, "trace_as_metadata": true, "load_from_db": false, "list": false, "list_add_label": "Add More", "required": false, "placeholder": "", "show": true, "name": "year", "value": "", "display_name": "Year", "advanced": false, "input_types": ["Message"], "dynamic": false, "info": "", "title_case": false, "type": "str", "_input_type": "MessageTextInput"}}, "description": "\u041a\u0443\u0440\u0441 \u0426\u0411 \u0420\u0424 \u043d\u0430 \u0434\u0430\u0442\u0443 \u0438 \u043a\u043e\u043d\u0432\u0435\u0440\u0442\u0430\u0446\u0438\u044f base\u2192target \u0447\u0435\u0440\u0435\u0437 \u043a\u0440\u043e\u0441\u0441\u2011\u043a\u0443\u0440\u0441.", "icon": "Currencies", "base_classes": ["Data"], "display_name": "CBR GetCursOnDate Converter", "documentation": "https://www.cbr.ru/development/dws/", "minimized": false, "custom_fields": {}, "output_types": [], "pinned": false, "conditional_paths": [], "frozen": false, "outputs": [{"types": ["Data"], "selected": "Data", "name": "output", "hidden": null, "display_name": "Result", "method": "build_output", "value": "__UNDEFINED__", "cache": true, "required_inputs": null, "allows_loop": false, "group_outputs": false, "options": null, "tool_mode": true}], "field_order": ["if_else_input", "day", "month", "year", "base_currency", "target_currency", "amount", "fallback_previous", "fallback_days", "timeout_sec"], "beta": false, "legacy": false, "edited": true, "metadata": {}, "tool_mode": false, "lf_version": "1.6.3"}, "showNode": true, "type": "CBRHistoricalConverter", "id": "CustomComponent-UuzJ9"}, "selected": false, "measured": {"width": 320, "height": 917}, "dragging": false}, {"id": "ParserComponent-3T0ZF", "type": "genericNode", "position": {"x": -236.5792773293693, "y": 1037.7839882369738}, "data": {"node": {"template": {"_type": "Component", "input_data": {"trace_as_metadata": true, "list": false, "list_add_label": "Add More", "required": true, "placeholder": "", "show": true, "name": "input_data", "value": "", "display_name": "Data or DataFrame", "advanced": false, "input_types": ["DataFrame", "Data"], "dynamic": false, "info": "Accepts either a DataFrame or a Data object.", "title_case": false, "type": "other", "_input_type": "HandleInput"}, "code": {"type": "code", "required": true, "placeholder": "", "list": false, "show": true, "multiline": true, "value": "from langflow.custom.custom_component.component import Component\nfrom langflow.helpers.data import safe_convert\nfrom langflow.inputs.inputs import BoolInput, HandleInput, MessageTextInput, MultilineInput, TabInput\nfrom langflow.schema.data import Data\nfrom langflow.schema.dataframe import DataFrame\nfrom langflow.schema.message import Message\nfrom langflow.template.field.base import Output\n\n\nclass ParserComponent(Component):\n    display_name = \"Parser\"\n    description = \"Extracts text using a template.\"\n    documentation: str = \"https://docs.langflow.org/components-processing#parser\"\n    icon = \"braces\"\n\n    inputs = [\n        HandleInput(\n            name=\"input_data\",\n            display_name=\"Data or DataFrame\",\n            input_types=[\"DataFrame\", \"Data\"],\n            info=\"Accepts either a DataFrame or a Data object.\",\n            required=True,\n        ),\n        TabInput(\n            name=\"mode\",\n            display_name=\"Mode\",\n            options=[\"Parser\", \"Stringify\"],\n            value=\"Parser\",\n            info=\"Convert into raw string instead of using a template.\",\n            real_time_refresh=True,\n        ),\n        MultilineInput(\n            name=\"pattern\",\n            display_name=\"Template\",\n            info=(\n                \"Use variables within curly brackets to extract column values for DataFrames \"\n                \"or key values for Data.\"\n                \"For example: `Name: {Name}, Age: {Age}, Country: {Country}`\"\n            ),\n            value=\"Text: {text}\",  # Example default\n            dynamic=True,\n            show=True,\n            required=True,\n        ),\n        MessageTextInput(\n            name=\"sep\",\n            display_name=\"Separator\",\n            advanced=True,\n            value=\"\\n\",\n            info=\"String used to separate rows/items.\",\n        ),\n    ]\n\n    outputs = [\n        Output(\n            display_name=\"Parsed Text\",\n            name=\"parsed_text\",\n            info=\"Formatted text output.\",\n            method=\"parse_combined_text\",\n        ),\n    ]\n\n    def update_build_config(self, build_config, field_value, field_name=None):\n        \"\"\"Dynamically hide/show `template` and enforce requirement based on `stringify`.\"\"\"\n        if field_name == \"mode\":\n            build_config[\"pattern\"][\"show\"] = self.mode == \"Parser\"\n            build_config[\"pattern\"][\"required\"] = self.mode == \"Parser\"\n            if field_value:\n                clean_data = BoolInput(\n                    name=\"clean_data\",\n                    display_name=\"Clean Data\",\n                    info=(\n                        \"Enable to clean the data by removing empty rows and lines \"\n                        \"in each cell of the DataFrame/ Data object.\"\n                    ),\n                    value=True,\n                    advanced=True,\n                    required=False,\n                )\n                build_config[\"clean_data\"] = clean_data.to_dict()\n            else:\n                build_config.pop(\"clean_data\", None)\n\n        return build_config\n\n    def _clean_args(self):\n        \"\"\"Prepare arguments based on input type.\"\"\"\n        input_data = self.input_data\n\n        match input_data:\n            case list() if all(isinstance(item, Data) for item in input_data):\n                msg = \"List of Data objects is not supported.\"\n                raise ValueError(msg)\n            case DataFrame():\n                return input_data, None\n            case Data():\n                return None, input_data\n            case dict() if \"data\" in input_data:\n                try:\n                    if \"columns\" in input_data:  # Likely a DataFrame\n                        return DataFrame.from_dict(input_data), None\n                    # Likely a Data object\n                    return None, Data(**input_data)\n                except (TypeError, ValueError, KeyError) as e:\n                    msg = f\"Invalid structured input provided: {e!s}\"\n                    raise ValueError(msg) from e\n            case _:\n                msg = f\"Unsupported input type: {type(input_data)}. Expected DataFrame or Data.\"\n                raise ValueError(msg)\n\n    def parse_combined_text(self) -> Message:\n        \"\"\"Parse all rows/items into a single text or convert input to string if `stringify` is enabled.\"\"\"\n        # Early return for stringify option\n        if self.mode == \"Stringify\":\n            return self.convert_to_string()\n\n        df, data = self._clean_args()\n\n        lines = []\n        if df is not None:\n            for _, row in df.iterrows():\n                formatted_text = self.pattern.format(**row.to_dict())\n                lines.append(formatted_text)\n        elif data is not None:\n            formatted_text = self.pattern.format(**data.data)\n            lines.append(formatted_text)\n\n        combined_text = self.sep.join(lines)\n        self.status = combined_text\n        return Message(text=combined_text)\n\n    def convert_to_string(self) -> Message:\n        \"\"\"Convert input data to string with proper error handling.\"\"\"\n        result = \"\"\n        if isinstance(self.input_data, list):\n            result = \"\\n\".join([safe_convert(item, clean_data=self.clean_data or False) for item in self.input_data])\n        else:\n            result = safe_convert(self.input_data or False)\n        self.log(f\"Converted to string with length: {len(result)}\")\n\n        message = Message(text=result)\n        self.status = message\n        return message\n", "fileTypes": [], "file_path": "", "password": false, "name": "code", "advanced": true, "dynamic": true, "info": "", "load_from_db": false, "title_case": false}, "mode": {"tool_mode": false, "trace_as_metadata": true, "options": ["Parser", "Stringify"], "required": false, "placeholder": "", "show": true, "name": "mode", "value": "Parser", "display_name": "Mode", "advanced": false, "dynamic": false, "info": "Convert into raw string instead of using a template.", "real_time_refresh": true, "title_case": false, "type": "tab", "_input_type": "TabInput"}, "pattern": {"tool_mode": false, "trace_as_input": true, "multiline": true, "trace_as_metadata": true, "load_from_db": false, "list": false, "list_add_label": "Add More", "required": true, "placeholder": "", "show": true, "name": "pattern", "value": "{year}", "display_name": "Template", "advanced": false, "input_types": ["Message"], "dynamic": true, "info": "Use variables within curly brackets to extract column values for DataFrames or key values for Data.For example: `Name: {Name}, Age: {Age}, Country: {Country}`", "title_case": false, "copy_field": false, "type": "str", "_input_type": "MultilineInput"}, "sep": {"tool_mode": false, "trace_as_input": true, "trace_as_metadata": true, "load_from_db": false, "list": false, "list_add_label": "Add More", "required": false, "placeholder": "", "show": true, "name": "sep", "value": "\n", "display_name": "Separator", "advanced": true, "input_types": ["Message"], "dynamic": false, "info": "String used to separate rows/items.", "title_case": false, "type": "str", "_input_type": "MessageTextInput"}}, "description": "Extracts text using a template.", "icon": "braces", "base_classes": ["Message"], "display_name": "Parser", "documentation": "https://docs.langflow.org/components-processing#parser", "minimized": false, "custom_fields": {}, "output_types": [], "pinned": false, "conditional_paths": [], "frozen": false, "outputs": [{"types": ["Message"], "selected": "Message", "name": "parsed_text", "display_name": "Parsed Text", "method": "parse_combined_text", "value": "__UNDEFINED__", "cache": true, "allows_loop": false, "group_outputs": false, "tool_mode": true}], "field_order": ["input_data", "mode", "pattern", "sep"], "beta": false, "legacy": false, "edited": false, "metadata": {}, "tool_mode": false, "category": "processing", "key": "ParserComponent", "score": 2.220446049250313e-16, "lf_version": "1.6.3"}, "showNode": true, "type": "ParserComponent", "id": "ParserComponent-3T0ZF"}, "selected": false, "measured": {"width": 320, "height": 327}, "dragging": false}, {"id": "CustomComponent-k8AUT", "type": "genericNode", "position": {"x": 307.11473412185865, "y": 886.5730060263531}, "data": {"node": {"template": {"_type": "Component", "currency_dict": {"tool_mode": false, "trace_as_metadata": true, "list": false, "list_add_label": "Add More", "trace_as_input": true, "required": false, "placeholder": "", "show": true, "name": "currency_dict", "value": "", "display_name": "Allowed Codes (Data)", "advanced": false, "input_types": ["Data"], "dynamic": false, "info": "JSON Data \u0441 \u0434\u043e\u043f\u0443\u0441\u0442\u0438\u043c\u044b\u043c\u0438 \u0432\u0430\u043b\u044e\u0442\u0430\u043c\u0438 (\u043a\u043b\u044e\u0447\u0438 \u2014 ISO 4217)", "title_case": false, "type": "other", "_input_type": "DataInput"}, "allow_today": {"tool_mode": false, "trace_as_metadata": true, "list": false, "list_add_label": "Add More", "required": false, "placeholder": "", "show": true, "name": "allow_today", "value": true, "display_name": "Allow today", "advanced": true, "dynamic": false, "info": "", "title_case": false, "type": "bool", "_input_type": "BoolInput"}, "base_currency": {"tool_mode": false, "trace_as_metadata": true, "load_from_db": false, "list": false, "list_add_label": "Add More", "required": false, "placeholder": "", "show": true, "name": "base_currency", "value": "", "display_name": "Base Currency", "advanced": false, "input_types": ["str", "Message"], "dynamic": false, "info": "ISO 4217, \u043d\u0430\u043f\u0440., USD", "title_case": false, "type": "str", "_input_type": "StrInput"}, "code": {"type": "code", "required": true, "placeholder": "", "list": false, "show": true, "multiline": true, "value": "from __future__ import annotations\r\nfrom typing import Any, Dict, List, Tuple\r\nfrom datetime import date, datetime\r\nfrom zoneinfo import ZoneInfo\r\n\r\nfrom langflow.custom import Component\r\nfrom langflow.io import (\r\n    DataInput,\r\n    StrInput,\r\n    MessageTextInput,\r\n    BoolInput,\r\n    Output,\r\n)\r\nfrom langflow.schema import Data\r\n\r\n\r\nclass CheckCurrencyAndDate(Component):\r\n    display_name = \"Check Currency & Date\"\r\n    description = \"\u0415\u0434\u0438\u043d\u0430\u044f \u0432\u0430\u043b\u0438\u0434\u0430\u0446\u0438\u044f: ISO \u0432\u0430\u043b\u044e\u0442 (base/target) \u0438 \u0434\u0430\u0442\u044b (YYYY-MM-DD, TZ, allow_today).\"\r\n    icon = \"Check\"\r\n    name = \"CheckCurrencyAndDate\"\r\n\r\n    inputs = [\r\n        DataInput(\r\n            name=\"currency_dict\",\r\n            display_name=\"Allowed Codes (Data)\",\r\n            info=\"JSON Data \u0441 \u0434\u043e\u043f\u0443\u0441\u0442\u0438\u043c\u044b\u043c\u0438 \u0432\u0430\u043b\u044e\u0442\u0430\u043c\u0438 (\u043a\u043b\u044e\u0447\u0438 \u2014 ISO 4217)\",\r\n            input_types=[\"Data\"],\r\n        ),\r\n        StrInput(\r\n            name=\"base_currency\",\r\n            display_name=\"Base Currency\",\r\n            info=\"ISO 4217, \u043d\u0430\u043f\u0440., USD\",\r\n            value=\"USD\",\r\n            input_types=[\"str\", \"Message\"],\r\n        ),\r\n        StrInput(\r\n            name=\"target_currency\",\r\n            display_name=\"Target Currency\",\r\n            info=\"ISO 4217, \u043d\u0430\u043f\u0440., RUB\",\r\n            value=\"RUB\",\r\n            input_types=[\"str\", \"Message\"],\r\n        ),\r\n        MessageTextInput(name=\"year\", display_name=\"Year\"),\r\n        MessageTextInput(name=\"month\", display_name=\"Month\"),\r\n        MessageTextInput(name=\"day\", display_name=\"Day\"),\r\n        StrInput(name=\"timezone\", display_name=\"Timezone\", value=\"Europe/Moscow\", advanced=True),\r\n        BoolInput(name=\"allow_today\", display_name=\"Allow today\", value=True, advanced=True),\r\n        BoolInput(name=\"include_rub\", display_name=\"Always allow RUB\", value=True, advanced=True),\r\n    ]\r\n\r\n    outputs = [\r\n        Output(display_name=\"Result (Data)\", name=\"output\", method=\"build_output\", type=\"Data\"),\r\n    ]\r\n\r\n    # --- helpers ---\r\n    def _get_text(self, v: Any) -> str:\r\n        try:\r\n            if hasattr(v, \"text\"):\r\n                return str(getattr(v, \"text\") or \"\")\r\n        except Exception:\r\n            pass\r\n        if isinstance(v, dict) and \"TEXT\" in v:\r\n            return str(v.get(\"TEXT\") or \"\")\r\n        return str(v or \"\")\r\n\r\n    def _normalize(self, s: Any) -> str:\r\n        return self._get_text(s).strip().upper()\r\n\r\n    def _allowed_codes(self) -> List[str]:\r\n        payload = self.currency_dict.data if hasattr(self.currency_dict, \"data\") else self.currency_dict\r\n        keys = []\r\n        if isinstance(payload, dict):\r\n            for k in payload.keys():\r\n                if isinstance(k, str):\r\n                    keys.append(k.strip().upper())\r\n        if bool(getattr(self, \"include_rub\", True)) and \"RUB\" not in keys:\r\n            keys.append(\"RUB\")\r\n        return keys\r\n\r\n    def _validate_date(self) -> Tuple[bool, str | None, Dict[str, int], str]:\r\n        tz = self.timezone or \"Europe/Moscow\"\r\n        try:\r\n            y = int(self.year); m = int(self.month); d = int(self.day)\r\n        except Exception:\r\n            return False, \"parse_error\", {}, tz\r\n\r\n        if not (1 <= y <= 9999 and 1 <= m <= 12 and 1 <= d <= 31):\r\n            return False, \"out_of_range\", {\"year\": y, \"month\": m, \"day\": d}, tz\r\n\r\n        try:\r\n            dt = date(y, m, d)\r\n        except ValueError:\r\n            return False, \"invalid_calendar_date\", {\"year\": y, \"month\": m, \"day\": d}, tz\r\n\r\n        allow_today = bool(getattr(self, \"allow_today\", True))\r\n        today = datetime.now(ZoneInfo(tz)).date()\r\n        if (dt > today) or (dt == today and not allow_today):\r\n            return False, \"future_date\", {\"year\": y, \"month\": m, \"day\": d}, tz\r\n\r\n        return True, None, {\"year\": y, \"month\": m, \"day\": d}, tz\r\n\r\n    # --- main ---\r\n    def build_output(self) -> Data:\r\n        base = self._normalize(self.base_currency)\r\n        target = self._normalize(self.target_currency)\r\n        allowed = set(self._allowed_codes())\r\n\r\n        errors: List[str] = []\r\n        warnings: List[str] = []\r\n\r\n        if not base:\r\n            errors.append(\"\u0422\u0440\u0435\u0431\u0443\u0435\u0442\u0441\u044f base_currency\")\r\n        if not target:\r\n            errors.append(\"\u0422\u0440\u0435\u0431\u0443\u0435\u0442\u0441\u044f target_currency\")\r\n\r\n        if base and base not in allowed:\r\n            errors.append(f\"Base \u0432\u0430\u043b\u044e\u0442\u0430 \u043d\u0435 \u043f\u043e\u0434\u0434\u0435\u0440\u0436\u0438\u0432\u0430\u0435\u0442\u0441\u044f: {base}\")\r\n        if target and target not in allowed:\r\n            errors.append(f\"Target \u0432\u0430\u043b\u044e\u0442\u0430 \u043d\u0435 \u043f\u043e\u0434\u0434\u0435\u0440\u0436\u0438\u0432\u0430\u0435\u0442\u0441\u044f: {target}\")\r\n\r\n        ok_date, reason, input_dt, tz = self._validate_date()\r\n        if not ok_date:\r\n            errors.append(f\"\u041d\u0435\u043a\u043e\u0440\u0440\u0435\u043a\u0442\u043d\u0430\u044f \u0434\u0430\u0442\u0430 ({reason})\")\r\n\r\n        ok = len(errors) == 0\r\n\r\n        data: Dict[str, Any] = {\r\n            \"ok\": ok,\r\n            \"base\": base,\r\n            \"target\": target,\r\n            \"input\": {\r\n                \"year\": input_dt.get(\"year\") if input_dt else None,\r\n                \"month\": input_dt.get(\"month\") if input_dt else None,\r\n                \"day\": input_dt.get(\"day\") if input_dt else None,\r\n            },\r\n            \"timezone\": tz,\r\n            \"errors\": errors,\r\n            \"warnings\": warnings,\r\n            \"normalized\": {\"base\": base, \"target\": target},\r\n        }\r\n\r\n        data_text = \"true\" if ok else \"false\"\r\n        return Data(data=data, text=data_text)\r\n", "fileTypes": [], "file_path": "", "password": false, "name": "code", "advanced": true, "dynamic": true, "info": "", "load_from_db": false, "title_case": false}, "day": {"tool_mode": false, "trace_as_input": true, "trace_as_metadata": true, "load_from_db": false, "list": false, "list_add_label": "Add More", "required": false, "placeholder": "", "show": true, "name": "day", "value": "", "display_name": "Day", "advanced": false, "input_types": ["Message"], "dynamic": false, "info": "", "title_case": false, "type": "str", "_input_type": "MessageTextInput"}, "include_rub": {"tool_mode": false, "trace_as_metadata": true, "list": false, "list_add_label": "Add More", "required": false, "placeholder": "", "show": true, "name": "include_rub", "value": true, "display_name": "Always allow RUB", "advanced": true, "dynamic": false, "info": "", "title_case": false, "type": "bool", "_input_type": "BoolInput"}, "month": {"tool_mode": false, "trace_as_input": true, "trace_as_metadata": true, "load_from_db": false, "list": false, "list_add_label": "Add More", "required": false, "placeholder": "", "show": true, "name": "month", "value": "", "display_name": "Month", "advanced": false, "input_types": ["Message"], "dynamic": false, "info": "", "title_case": false, "type": "str", "_input_type": "MessageTextInput"}, "target_currency": {"tool_mode": false, "trace_as_metadata": true, "load_from_db": false, "list": false, "list_add_label": "Add More", "required": false, "placeholder": "", "show": true, "name": "target_currency", "value": "", "display_name": "Target Currency", "advanced": false, "input_types": ["str", "Message"], "dynamic": false, "info": "ISO 4217, \u043d\u0430\u043f\u0440., RUB", "title_case": false, "type": "str", "_input_type": "StrInput"}, "timezone": {"tool_mode": false, "trace_as_metadata": true, "load_from_db": false, "list": false, "list_add_label": "Add More", "required": false, "placeholder": "", "show": true, "name": "timezone", "value": "Europe/Moscow", "display_name": "Timezone", "advanced": true, "dynamic": false, "info": "", "title_case": false, "type": "str", "_input_type": "StrInput"}, "year": {"tool_mode": false, "trace_as_input": true, "trace_as_metadata": true, "load_from_db": false, "list": false, "list_add_label": "Add More", "required": false, "placeholder": "", "show": true, "name": "year", "value": "", "display_name": "Year", "advanced": false, "input_types": ["Message"], "dynamic": false, "info": "", "title_case": false, "type": "str", "_input_type": "MessageTextInput"}}, "description": "\u0415\u0434\u0438\u043d\u0430\u044f \u0432\u0430\u043b\u0438\u0434\u0430\u0446\u0438\u044f: ISO \u0432\u0430\u043b\u044e\u0442 (base/target) \u0438 \u0434\u0430\u0442\u044b (YYYY-MM-DD, TZ, allow_today).", "icon": "Check", "base_classes": ["Data"], "display_name": "Check Currency & Date", "documentation": "", "minimized": false, "custom_fields": {}, "output_types": [], "pinned": false, "conditional_paths": [], "frozen": false, "outputs": [{"types": ["Data"], "selected": "Data", "name": "output", "hidden": null, "display_name": "Result (Data)", "method": "build_output", "value": "__UNDEFINED__", "cache": true, "required_inputs": null, "allows_loop": false, "group_outputs": false, "options": null, "tool_mode": true}], "field_order": ["currency_dict", "base_currency", "target_currency", "year", "month", "day", "timezone", "allow_today", "include_rub"], "beta": false, "legacy": false, "edited": true, "metadata": {}, "tool_mode": false, "lf_version": "1.6.3"}, "showNode": true, "type": "CheckCurrencyAndDate", "id": "CustomComponent-k8AUT"}, "selected": false, "measured": {"width": 320, "height": 591}, "dragging": false}, {"id": "ParserComponent-YCFN7", "type": "genericNode", "position": {"x": -232.90882533391556, "y": 1380.7037635573304}, "data": {"node": {"template": {"_type": "Component", "input_data": {"trace_as_metadata": true, "list": false, "list_add_label": "Add More", "required": true, "placeholder": "", "show": true, "name": "input_data", "value": "", "display_name": "Data or DataFrame", "advanced": false, "input_types": ["DataFrame", "Data"], "dynamic": false, "info": "Accepts either a DataFrame or a Data object.", "title_case": false, "type": "other", "_input_type": "HandleInput"}, "code": {"type": "code", "required": true, "placeholder": "", "list": false, "show": true, "multiline": true, "value": "from langflow.custom.custom_component.component import Component\nfrom langflow.helpers.data import safe_convert\nfrom langflow.inputs.inputs import BoolInput, HandleInput, MessageTextInput, MultilineInput, TabInput\nfrom langflow.schema.data import Data\nfrom langflow.schema.dataframe import DataFrame\nfrom langflow.schema.message import Message\nfrom langflow.template.field.base import Output\n\n\nclass ParserComponent(Component):\n    display_name = \"Parser\"\n    description = \"Extracts text using a template.\"\n    documentation: str = \"https://docs.langflow.org/components-processing#parser\"\n    icon = \"braces\"\n\n    inputs = [\n        HandleInput(\n            name=\"input_data\",\n            display_name=\"Data or DataFrame\",\n            input_types=[\"DataFrame\", \"Data\"],\n            info=\"Accepts either a DataFrame or a Data object.\",\n            required=True,\n        ),\n        TabInput(\n            name=\"mode\",\n            display_name=\"Mode\",\n            options=[\"Parser\", \"Stringify\"],\n            value=\"Parser\",\n            info=\"Convert into raw string instead of using a template.\",\n            real_time_refresh=True,\n        ),\n        MultilineInput(\n            name=\"pattern\",\n            display_name=\"Template\",\n            info=(\n                \"Use variables within curly brackets to extract column values for DataFrames \"\n                \"or key values for Data.\"\n                \"For example: `Name: {Name}, Age: {Age}, Country: {Country}`\"\n            ),\n            value=\"Text: {text}\",  # Example default\n            dynamic=True,\n            show=True,\n            required=True,\n        ),\n        MessageTextInput(\n            name=\"sep\",\n            display_name=\"Separator\",\n            advanced=True,\n            value=\"\\n\",\n            info=\"String used to separate rows/items.\",\n        ),\n    ]\n\n    outputs = [\n        Output(\n            display_name=\"Parsed Text\",\n            name=\"parsed_text\",\n            info=\"Formatted text output.\",\n            method=\"parse_combined_text\",\n        ),\n    ]\n\n    def update_build_config(self, build_config, field_value, field_name=None):\n        \"\"\"Dynamically hide/show `template` and enforce requirement based on `stringify`.\"\"\"\n        if field_name == \"mode\":\n            build_config[\"pattern\"][\"show\"] = self.mode == \"Parser\"\n            build_config[\"pattern\"][\"required\"] = self.mode == \"Parser\"\n            if field_value:\n                clean_data = BoolInput(\n                    name=\"clean_data\",\n                    display_name=\"Clean Data\",\n                    info=(\n                        \"Enable to clean the data by removing empty rows and lines \"\n                        \"in each cell of the DataFrame/ Data object.\"\n                    ),\n                    value=True,\n                    advanced=True,\n                    required=False,\n                )\n                build_config[\"clean_data\"] = clean_data.to_dict()\n            else:\n                build_config.pop(\"clean_data\", None)\n\n        return build_config\n\n    def _clean_args(self):\n        \"\"\"Prepare arguments based on input type.\"\"\"\n        input_data = self.input_data\n\n        match input_data:\n            case list() if all(isinstance(item, Data) for item in input_data):\n                msg = \"List of Data objects is not supported.\"\n                raise ValueError(msg)\n            case DataFrame():\n                return input_data, None\n            case Data():\n                return None, input_data\n            case dict() if \"data\" in input_data:\n                try:\n                    if \"columns\" in input_data:  # Likely a DataFrame\n                        return DataFrame.from_dict(input_data), None\n                    # Likely a Data object\n                    return None, Data(**input_data)\n                except (TypeError, ValueError, KeyError) as e:\n                    msg = f\"Invalid structured input provided: {e!s}\"\n                    raise ValueError(msg) from e\n            case _:\n                msg = f\"Unsupported input type: {type(input_data)}. Expected DataFrame or Data.\"\n                raise ValueError(msg)\n\n    def parse_combined_text(self) -> Message:\n        \"\"\"Parse all rows/items into a single text or convert input to string if `stringify` is enabled.\"\"\"\n        # Early return for stringify option\n        if self.mode == \"Stringify\":\n            return self.convert_to_string()\n\n        df, data = self._clean_args()\n\n        lines = []\n        if df is not None:\n            for _, row in df.iterrows():\n                formatted_text = self.pattern.format(**row.to_dict())\n                lines.append(formatted_text)\n        elif data is not None:\n            formatted_text = self.pattern.format(**data.data)\n            lines.append(formatted_text)\n\n        combined_text = self.sep.join(lines)\n        self.status = combined_text\n        return Message(text=combined_text)\n\n    def convert_to_string(self) -> Message:\n        \"\"\"Convert input data to string with proper error handling.\"\"\"\n        result = \"\"\n        if isinstance(self.input_data, list):\n            result = \"\\n\".join([safe_convert(item, clean_data=self.clean_data or False) for item in self.input_data])\n        else:\n            result = safe_convert(self.input_data or False)\n        self.log(f\"Converted to string with length: {len(result)}\")\n\n        message = Message(text=result)\n        self.status = message\n        return message\n", "fileTypes": [], "file_path": "", "password": false, "name": "code", "advanced": true, "dynamic": true, "info": "", "load_from_db": false, "title_case": false}, "mode": {"tool_mode": false, "trace_as_metadata": true, "options": ["Parser", "Stringify"], "required": false, "placeholder": "", "show": true, "name": "mode", "value": "Parser", "display_name": "Mode", "advanced": false, "dynamic": false, "info": "Convert into raw string instead of using a template.", "real_time_refresh": true, "title_case": false, "type": "tab", "_input_type": "TabInput"}, "pattern": {"tool_mode": false, "trace_as_input": true, "multiline": true, "trace_as_metadata": true, "load_from_db": false, "list": false, "list_add_label": "Add More", "required": true, "placeholder": "", "show": true, "name": "pattern", "value": "{month}", "display_name": "Template", "advanced": false, "input_types": ["Message"], "dynamic": true, "info": "Use variables within curly brackets to extract column values for DataFrames or key values for Data.For example: `Name: {Name}, Age: {Age}, Country: {Country}`", "title_case": false, "copy_field": false, "type": "str", "_input_type": "MultilineInput"}, "sep": {"tool_mode": false, "trace_as_input": true, "trace_as_metadata": true, "load_from_db": false, "list": false, "list_add_label": "Add More", "required": false, "placeholder": "", "show": true, "name": "sep", "value": "\n", "display_name": "Separator", "advanced": true, "input_types": ["Message"], "dynamic": false, "info": "String used to separate rows/items.", "title_case": false, "type": "str", "_input_type": "MessageTextInput"}}, "description": "Extracts text using a template.", "icon": "braces", "base_classes": ["Message"], "display_name": "Parser", "documentation": "https://docs.langflow.org/components-processing#parser", "minimized": false, "custom_fields": {}, "output_types": [], "pinned": false, "conditional_paths": [], "frozen": false, "outputs": [{"types": ["Message"], "selected": "Message", "name": "parsed_text", "display_name": "Parsed Text", "method": "parse_combined_text", "value": "__UNDEFINED__", "cache": true, "allows_loop": false, "group_outputs": false, "tool_mode": true}], "field_order": ["input_data", "mode", "pattern", "sep"], "beta": false, "legacy": false, "edited": false, "metadata": {}, "tool_mode": false, "category": "processing", "key": "ParserComponent", "score": 2.220446049250313e-16, "lf_version": "1.6.3"}, "showNode": true, "type": "ParserComponent", "id": "ParserComponent-YCFN7"}, "selected": false, "measured": {"width": 320, "height": 327}, "dragging": false}, {"id": "ParserComponent-ah5TP", "type": "genericNode", "position": {"x": -223.81452593485312, "y": 1742.9600229533157}, "data": {"node": {"template": {"_type": "Component", "input_data": {"trace_as_metadata": true, "list": false, "list_add_label": "Add More", "required": true, "placeholder": "", "show": true, "name": "input_data", "value": "", "display_name": "Data or DataFrame", "advanced": false, "input_types": ["DataFrame", "Data"], "dynamic": false, "info": "Accepts either a DataFrame or a Data object.", "title_case": false, "type": "other", "_input_type": "HandleInput"}, "code": {"type": "code", "required": true, "placeholder": "", "list": false, "show": true, "multiline": true, "value": "from langflow.custom.custom_component.component import Component\nfrom langflow.helpers.data import safe_convert\nfrom langflow.inputs.inputs import BoolInput, HandleInput, MessageTextInput, MultilineInput, TabInput\nfrom langflow.schema.data import Data\nfrom langflow.schema.dataframe import DataFrame\nfrom langflow.schema.message import Message\nfrom langflow.template.field.base import Output\n\n\nclass ParserComponent(Component):\n    display_name = \"Parser\"\n    description = \"Extracts text using a template.\"\n    documentation: str = \"https://docs.langflow.org/components-processing#parser\"\n    icon = \"braces\"\n\n    inputs = [\n        HandleInput(\n            name=\"input_data\",\n            display_name=\"Data or DataFrame\",\n            input_types=[\"DataFrame\", \"Data\"],\n            info=\"Accepts either a DataFrame or a Data object.\",\n            required=True,\n        ),\n        TabInput(\n            name=\"mode\",\n            display_name=\"Mode\",\n            options=[\"Parser\", \"Stringify\"],\n            value=\"Parser\",\n            info=\"Convert into raw string instead of using a template.\",\n            real_time_refresh=True,\n        ),\n        MultilineInput(\n            name=\"pattern\",\n            display_name=\"Template\",\n            info=(\n                \"Use variables within curly brackets to extract column values for DataFrames \"\n                \"or key values for Data.\"\n                \"For example: `Name: {Name}, Age: {Age}, Country: {Country}`\"\n            ),\n            value=\"Text: {text}\",  # Example default\n            dynamic=True,\n            show=True,\n            required=True,\n        ),\n        MessageTextInput(\n            name=\"sep\",\n            display_name=\"Separator\",\n            advanced=True,\n            value=\"\\n\",\n            info=\"String used to separate rows/items.\",\n        ),\n    ]\n\n    outputs = [\n        Output(\n            display_name=\"Parsed Text\",\n            name=\"parsed_text\",\n            info=\"Formatted text output.\",\n            method=\"parse_combined_text\",\n        ),\n    ]\n\n    def update_build_config(self, build_config, field_value, field_name=None):\n        \"\"\"Dynamically hide/show `template` and enforce requirement based on `stringify`.\"\"\"\n        if field_name == \"mode\":\n            build_config[\"pattern\"][\"show\"] = self.mode == \"Parser\"\n            build_config[\"pattern\"][\"required\"] = self.mode == \"Parser\"\n            if field_value:\n                clean_data = BoolInput(\n                    name=\"clean_data\",\n                    display_name=\"Clean Data\",\n                    info=(\n                        \"Enable to clean the data by removing empty rows and lines \"\n                        \"in each cell of the DataFrame/ Data object.\"\n                    ),\n                    value=True,\n                    advanced=True,\n                    required=False,\n                )\n                build_config[\"clean_data\"] = clean_data.to_dict()\n            else:\n                build_config.pop(\"clean_data\", None)\n\n        return build_config\n\n    def _clean_args(self):\n        \"\"\"Prepare arguments based on input type.\"\"\"\n        input_data = self.input_data\n\n        match input_data:\n            case list() if all(isinstance(item, Data) for item in input_data):\n                msg = \"List of Data objects is not supported.\"\n                raise ValueError(msg)\n            case DataFrame():\n                return input_data, None\n            case Data():\n                return None, input_data\n            case dict() if \"data\" in input_data:\n                try:\n                    if \"columns\" in input_data:  # Likely a DataFrame\n                        return DataFrame.from_dict(input_data), None\n                    # Likely a Data object\n                    return None, Data(**input_data)\n                except (TypeError, ValueError, KeyError) as e:\n                    msg = f\"Invalid structured input provided: {e!s}\"\n                    raise ValueError(msg) from e\n            case _:\n                msg = f\"Unsupported input type: {type(input_data)}. Expected DataFrame or Data.\"\n                raise ValueError(msg)\n\n    def parse_combined_text(self) -> Message:\n        \"\"\"Parse all rows/items into a single text or convert input to string if `stringify` is enabled.\"\"\"\n        # Early return for stringify option\n        if self.mode == \"Stringify\":\n            return self.convert_to_string()\n\n        df, data = self._clean_args()\n\n        lines = []\n        if df is not None:\n            for _, row in df.iterrows():\n                formatted_text = self.pattern.format(**row.to_dict())\n                lines.append(formatted_text)\n        elif data is not None:\n            formatted_text = self.pattern.format(**data.data)\n            lines.append(formatted_text)\n\n        combined_text = self.sep.join(lines)\n        self.status = combined_text\n        return Message(text=combined_text)\n\n    def convert_to_string(self) -> Message:\n        \"\"\"Convert input data to string with proper error handling.\"\"\"\n        result = \"\"\n        if isinstance(self.input_data, list):\n            result = \"\\n\".join([safe_convert(item, clean_data=self.clean_data or False) for item in self.input_data])\n        else:\n            result = safe_convert(self.input_data or False)\n        self.log(f\"Converted to string with length: {len(result)}\")\n\n        message = Message(text=result)\n        self.status = message\n        return message\n", "fileTypes": [], "file_path": "", "password": false, "name": "code", "advanced": true, "dynamic": true, "info": "", "load_from_db": false, "title_case": false}, "mode": {"tool_mode": false, "trace_as_metadata": true, "options": ["Parser", "Stringify"], "required": false, "placeholder": "", "show": true, "name": "mode", "value": "Parser", "display_name": "Mode", "advanced": false, "dynamic": false, "info": "Convert into raw string instead of using a template.", "real_time_refresh": true, "title_case": false, "type": "tab", "_input_type": "TabInput"}, "pattern": {"tool_mode": false, "trace_as_input": true, "multiline": true, "trace_as_metadata": true, "load_from_db": false, "list": false, "list_add_label": "Add More", "required": true, "placeholder": "", "show": true, "name": "pattern", "value": "{day}", "display_name": "Template", "advanced": false, "input_types": ["Message"], "dynamic": true, "info": "Use variables within curly brackets to extract column values for DataFrames or key values for Data.For example: `Name: {Name}, Age: {Age}, Country: {Country}`", "title_case": false, "copy_field": false, "type": "str", "_input_type": "MultilineInput"}, "sep": {"tool_mode": false, "trace_as_input": true, "trace_as_metadata": true, "load_from_db": false, "list": false, "list_add_label": "Add More", "required": false, "placeholder": "", "show": true, "name": "sep", "value": "\n", "display_name": "Separator", "advanced": true, "input_types": ["Message"], "dynamic": false, "info": "String used to separate rows/items.", "title_case": false, "type": "str", "_input_type": "MessageTextInput"}}, "description": "Extracts text using a template.", "icon": "braces", "base_classes": ["Message"], "display_name": "Parser", "documentation": "https://docs.langflow.org/components-processing#parser", "minimized": false, "custom_fields": {}, "output_types": [], "pinned": false, "conditional_paths": [], "frozen": false, "outputs": [{"types": ["Message"], "selected": "Message", "name": "parsed_text", "display_name": "Parsed Text", "method": "parse_combined_text", "value": "__UNDEFINED__", "cache": true, "allows_loop": false, "group_outputs": false, "tool_mode": true}], "field_order": ["input_data", "mode", "pattern", "sep"], "beta": false, "legacy": false, "edited": false, "metadata": {}, "tool_mode": false, "category": "processing", "key": "ParserComponent", "score": 2.220446049250313e-16, "lf_version": "1.6.3"}, "showNode": true, "type": "ParserComponent", "id": "ParserComponent-ah5TP"}, "selected": false, "measured": {"width": 320, "height": 327}, "dragging": false}, {"id": "ParserComponent-LO6Cp", "type": "genericNode", "position": {"x": 746.2440766318016, "y": 1103.3276318859278}, "data": {"node": {"template": {"_type": "Component", "input_data": {"trace_as_metadata": true, "list": false, "list_add_label": "Add More", "required": true, "placeholder": "", "show": true, "name": "input_data", "value": "", "display_name": "Data or DataFrame", "advanced": false, "input_types": ["DataFrame", "Data"], "dynamic": false, "info": "Accepts either a DataFrame or a Data object.", "title_case": false, "type": "other", "_input_type": "HandleInput"}, "code": {"type": "code", "required": true, "placeholder": "", "list": false, "show": true, "multiline": true, "value": "from langflow.custom.custom_component.component import Component\nfrom langflow.helpers.data import safe_convert\nfrom langflow.inputs.inputs import BoolInput, HandleInput, MessageTextInput, MultilineInput, TabInput\nfrom langflow.schema.data import Data\nfrom langflow.schema.dataframe import DataFrame\nfrom langflow.schema.message import Message\nfrom langflow.template.field.base import Output\n\n\nclass ParserComponent(Component):\n    display_name = \"Parser\"\n    description = \"Extracts text using a template.\"\n    documentation: str = \"https://docs.langflow.org/components-processing#parser\"\n    icon = \"braces\"\n\n    inputs = [\n        HandleInput(\n            name=\"input_data\",\n            display_name=\"Data or DataFrame\",\n            input_types=[\"DataFrame\", \"Data\"],\n            info=\"Accepts either a DataFrame or a Data object.\",\n            required=True,\n        ),\n        TabInput(\n            name=\"mode\",\n            display_name=\"Mode\",\n            options=[\"Parser\", \"Stringify\"],\n            value=\"Parser\",\n            info=\"Convert into raw string instead of using a template.\",\n            real_time_refresh=True,\n        ),\n        MultilineInput(\n            name=\"pattern\",\n            display_name=\"Template\",\n            info=(\n                \"Use variables within curly brackets to extract column values for DataFrames \"\n                \"or key values for Data.\"\n                \"For example: `Name: {Name}, Age: {Age}, Country: {Country}`\"\n            ),\n            value=\"Text: {text}\",  # Example default\n            dynamic=True,\n            show=True,\n            required=True,\n        ),\n        MessageTextInput(\n            name=\"sep\",\n            display_name=\"Separator\",\n            advanced=True,\n            value=\"\\n\",\n            info=\"String used to separate rows/items.\",\n        ),\n    ]\n\n    outputs = [\n        Output(\n            display_name=\"Parsed Text\",\n            name=\"parsed_text\",\n            info=\"Formatted text output.\",\n            method=\"parse_combined_text\",\n        ),\n    ]\n\n    def update_build_config(self, build_config, field_value, field_name=None):\n        \"\"\"Dynamically hide/show `template` and enforce requirement based on `stringify`.\"\"\"\n        if field_name == \"mode\":\n            build_config[\"pattern\"][\"show\"] = self.mode == \"Parser\"\n            build_config[\"pattern\"][\"required\"] = self.mode == \"Parser\"\n            if field_value:\n                clean_data = BoolInput(\n                    name=\"clean_data\",\n                    display_name=\"Clean Data\",\n                    info=(\n                        \"Enable to clean the data by removing empty rows and lines \"\n                        \"in each cell of the DataFrame/ Data object.\"\n                    ),\n                    value=True,\n                    advanced=True,\n                    required=False,\n                )\n                build_config[\"clean_data\"] = clean_data.to_dict()\n            else:\n                build_config.pop(\"clean_data\", None)\n\n        return build_config\n\n    def _clean_args(self):\n        \"\"\"Prepare arguments based on input type.\"\"\"\n        input_data = self.input_data\n\n        match input_data:\n            case list() if all(isinstance(item, Data) for item in input_data):\n                msg = \"List of Data objects is not supported.\"\n                raise ValueError(msg)\n            case DataFrame():\n                return input_data, None\n            case Data():\n                return None, input_data\n            case dict() if \"data\" in input_data:\n                try:\n                    if \"columns\" in input_data:  # Likely a DataFrame\n                        return DataFrame.from_dict(input_data), None\n                    # Likely a Data object\n                    return None, Data(**input_data)\n                except (TypeError, ValueError, KeyError) as e:\n                    msg = f\"Invalid structured input provided: {e!s}\"\n                    raise ValueError(msg) from e\n            case _:\n                msg = f\"Unsupported input type: {type(input_data)}. Expected DataFrame or Data.\"\n                raise ValueError(msg)\n\n    def parse_combined_text(self) -> Message:\n        \"\"\"Parse all rows/items into a single text or convert input to string if `stringify` is enabled.\"\"\"\n        # Early return for stringify option\n        if self.mode == \"Stringify\":\n            return self.convert_to_string()\n\n        df, data = self._clean_args()\n\n        lines = []\n        if df is not None:\n            for _, row in df.iterrows():\n                formatted_text = self.pattern.format(**row.to_dict())\n                lines.append(formatted_text)\n        elif data is not None:\n            formatted_text = self.pattern.format(**data.data)\n            lines.append(formatted_text)\n\n        combined_text = self.sep.join(lines)\n        self.status = combined_text\n        return Message(text=combined_text)\n\n    def convert_to_string(self) -> Message:\n        \"\"\"Convert input data to string with proper error handling.\"\"\"\n        result = \"\"\n        if isinstance(self.input_data, list):\n            result = \"\\n\".join([safe_convert(item, clean_data=self.clean_data or False) for item in self.input_data])\n        else:\n            result = safe_convert(self.input_data or False)\n        self.log(f\"Converted to string with length: {len(result)}\")\n\n        message = Message(text=result)\n        self.status = message\n        return message\n", "fileTypes": [], "file_path": "", "password": false, "name": "code", "advanced": true, "dynamic": true, "info": "", "load_from_db": false, "title_case": false}, "mode": {"tool_mode": false, "trace_as_metadata": true, "options": ["Parser", "Stringify"], "required": false, "placeholder": "", "show": true, "name": "mode", "value": "Parser", "display_name": "Mode", "advanced": false, "dynamic": false, "info": "Convert into raw string instead of using a template.", "real_time_refresh": true, "title_case": false, "type": "tab", "_input_type": "TabInput"}, "pattern": {"tool_mode": false, "trace_as_input": true, "multiline": true, "trace_as_metadata": true, "load_from_db": false, "list": false, "list_add_label": "Add More", "required": true, "placeholder": "", "show": true, "name": "pattern", "value": "{ok}", "display_name": "Template", "advanced": false, "input_types": ["Message"], "dynamic": true, "info": "Use variables within curly brackets to extract column values for DataFrames or key values for Data.For example: `Name: {Name}, Age: {Age}, Country: {Country}`", "title_case": false, "copy_field": false, "type": "str", "_input_type": "MultilineInput"}, "sep": {"tool_mode": false, "trace_as_input": true, "trace_as_metadata": true, "load_from_db": false, "list": false, "list_add_label": "Add More", "required": false, "placeholder": "", "show": true, "name": "sep", "value": "\n", "display_name": "Separator", "advanced": true, "input_types": ["Message"], "dynamic": false, "info": "String used to separate rows/items.", "title_case": false, "type": "str", "_input_type": "MessageTextInput"}}, "description": "Extracts text using a template.", "icon": "braces", "base_classes": ["Message"], "display_name": "Parser", "documentation": "https://docs.langflow.org/components-processing#parser", "minimized": false, "custom_fields": {}, "output_types": [], "pinned": false, "conditional_paths": [], "frozen": false, "outputs": [{"types": ["Message"], "selected": "Message", "name": "parsed_text", "display_name": "Parsed Text", "method": "parse_combined_text", "value": "__UNDEFINED__", "cache": true, "allows_loop": false, "group_outputs": false, "tool_mode": true}], "field_order": ["input_data", "mode", "pattern", "sep"], "beta": false, "legacy": false, "edited": false, "metadata": {}, "tool_mode": false, "category": "processing", "key": "ParserComponent", "score": 2.220446049250313e-16, "lf_version": "1.6.3"}, "showNode": true, "type": "ParserComponent", "id": "ParserComponent-LO6Cp"}, "selected": false, "measured": {"width": 320, "height": 327}, "dragging": false}, {"id": "ConditionalRouter-rdWpU", "type": "genericNode", "position": {"x": 1167.6132821216922, "y": 1256.415005103478}, "data": {"node": {"template": {"_type": "Component", "case_sensitive": {"tool_mode": false, "trace_as_metadata": true, "list": false, "list_add_label": "Add More", "required": false, "placeholder": "", "show": true, "name": "case_sensitive", "value": true, "display_name": "Case Sensitive", "advanced": true, "dynamic": false, "info": "If true, the comparison will be case sensitive.", "title_case": false, "type": "bool", "_input_type": "BoolInput"}, "code": {"type": "code", "required": true, "placeholder": "", "list": false, "show": true, "multiline": true, "value": "import re\n\nfrom langflow.custom.custom_component.component import Component\nfrom langflow.io import BoolInput, DropdownInput, IntInput, MessageInput, MessageTextInput, Output\nfrom langflow.schema.message import Message\n\n\nclass ConditionalRouterComponent(Component):\n    display_name = \"If-Else\"\n    description = \"Routes an input message to a corresponding output based on text comparison.\"\n    documentation: str = \"https://docs.langflow.org/components-logic#conditional-router-if-else-component\"\n    icon = \"split\"\n    name = \"ConditionalRouter\"\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self.__iteration_updated = False\n\n    inputs = [\n        MessageTextInput(\n            name=\"input_text\",\n            display_name=\"Text Input\",\n            info=\"The primary text input for the operation.\",\n            required=True,\n        ),\n        DropdownInput(\n            name=\"operator\",\n            display_name=\"Operator\",\n            options=[\n                \"equals\",\n                \"not equals\",\n                \"contains\",\n                \"starts with\",\n                \"ends with\",\n                \"regex\",\n                \"less than\",\n                \"less than or equal\",\n                \"greater than\",\n                \"greater than or equal\",\n            ],\n            info=\"The operator to apply for comparing the texts.\",\n            value=\"equals\",\n            real_time_refresh=True,\n        ),\n        MessageTextInput(\n            name=\"match_text\",\n            display_name=\"Match Text\",\n            info=\"The text input to compare against.\",\n            required=True,\n        ),\n        BoolInput(\n            name=\"case_sensitive\",\n            display_name=\"Case Sensitive\",\n            info=\"If true, the comparison will be case sensitive.\",\n            value=True,\n            advanced=True,\n        ),\n        MessageInput(\n            name=\"true_case_message\",\n            display_name=\"Case True\",\n            info=\"The message to pass if the condition is True.\",\n            advanced=True,\n        ),\n        MessageInput(\n            name=\"false_case_message\",\n            display_name=\"Case False\",\n            info=\"The message to pass if the condition is False.\",\n            advanced=True,\n        ),\n        IntInput(\n            name=\"max_iterations\",\n            display_name=\"Max Iterations\",\n            info=\"The maximum number of iterations for the conditional router.\",\n            value=10,\n            advanced=True,\n        ),\n        DropdownInput(\n            name=\"default_route\",\n            display_name=\"Default Route\",\n            options=[\"true_result\", \"false_result\"],\n            info=\"The default route to take when max iterations are reached.\",\n            value=\"false_result\",\n            advanced=True,\n        ),\n    ]\n\n    outputs = [\n        Output(display_name=\"True\", name=\"true_result\", method=\"true_response\", group_outputs=True),\n        Output(display_name=\"False\", name=\"false_result\", method=\"false_response\", group_outputs=True),\n    ]\n\n    def _pre_run_setup(self):\n        self.__iteration_updated = False\n\n    def evaluate_condition(self, input_text: str, match_text: str, operator: str, *, case_sensitive: bool) -> bool:\n        if not case_sensitive and operator != \"regex\":\n            input_text = input_text.lower()\n            match_text = match_text.lower()\n\n        if operator == \"equals\":\n            return input_text == match_text\n        if operator == \"not equals\":\n            return input_text != match_text\n        if operator == \"contains\":\n            return match_text in input_text\n        if operator == \"starts with\":\n            return input_text.startswith(match_text)\n        if operator == \"ends with\":\n            return input_text.endswith(match_text)\n        if operator == \"regex\":\n            try:\n                return bool(re.match(match_text, input_text))\n            except re.error:\n                return False  # Return False if the regex is invalid\n        if operator in [\"less than\", \"less than or equal\", \"greater than\", \"greater than or equal\"]:\n            try:\n                input_num = float(input_text)\n                match_num = float(match_text)\n                if operator == \"less than\":\n                    return input_num < match_num\n                if operator == \"less than or equal\":\n                    return input_num <= match_num\n                if operator == \"greater than\":\n                    return input_num > match_num\n                if operator == \"greater than or equal\":\n                    return input_num >= match_num\n            except ValueError:\n                return False  # Invalid number format for comparison\n        return False\n\n    def iterate_and_stop_once(self, route_to_stop: str):\n        \"\"\"Handles cycle iteration counting and branch exclusion.\n\n        Uses two complementary mechanisms:\n        1. stop() - ACTIVE/INACTIVE state for cycle management (gets reset each iteration)\n        2. exclude_branch_conditionally() - Persistent exclusion for conditional routing\n\n        When max_iterations is reached, breaks the cycle by allowing the default_route to execute.\n        \"\"\"\n        if not self.__iteration_updated:\n            self.update_ctx({f\"{self._id}_iteration\": self.ctx.get(f\"{self._id}_iteration\", 0) + 1})\n            self.__iteration_updated = True\n            current_iteration = self.ctx.get(f\"{self._id}_iteration\", 0)\n\n            # Check if max iterations reached and we're trying to stop the default route\n            if current_iteration >= self.max_iterations and route_to_stop == self.default_route:\n                # Clear ALL conditional exclusions to allow default route to execute\n                if self._id in self.graph.conditional_exclusion_sources:\n                    previous_exclusions = self.graph.conditional_exclusion_sources[self._id]\n                    self.graph.conditionally_excluded_vertices -= previous_exclusions\n                    del self.graph.conditional_exclusion_sources[self._id]\n\n                # Switch which route to stop - stop the NON-default route to break the cycle\n                route_to_stop = \"true_result\" if route_to_stop == \"false_result\" else \"false_result\"\n\n                # Call stop to break the cycle\n                self.stop(route_to_stop)\n                # Don't apply conditional exclusion when breaking cycle\n                return\n\n            # Normal case: Use BOTH mechanisms\n            # 1. stop() for cycle management (marks INACTIVE, updates run manager, gets reset)\n            self.stop(route_to_stop)\n\n            # 2. Conditional exclusion for persistent routing (doesn't get reset except by this router)\n            self.graph.exclude_branch_conditionally(self._id, output_name=route_to_stop)\n\n    def true_response(self) -> Message:\n        result = self.evaluate_condition(\n            self.input_text, self.match_text, self.operator, case_sensitive=self.case_sensitive\n        )\n\n        # Check if we should force output due to max_iterations on default route\n        current_iteration = self.ctx.get(f\"{self._id}_iteration\", 0)\n        force_output = current_iteration >= self.max_iterations and self.default_route == \"true_result\"\n\n        if result or force_output:\n            self.status = self.true_case_message\n            if not force_output:  # Only stop the other branch if not forcing due to max iterations\n                self.iterate_and_stop_once(\"false_result\")\n            return self.true_case_message\n        self.iterate_and_stop_once(\"true_result\")\n        return Message(content=\"\")\n\n    def false_response(self) -> Message:\n        result = self.evaluate_condition(\n            self.input_text, self.match_text, self.operator, case_sensitive=self.case_sensitive\n        )\n\n        if not result:\n            self.status = self.false_case_message\n            self.iterate_and_stop_once(\"true_result\")\n            return self.false_case_message\n\n        self.iterate_and_stop_once(\"false_result\")\n        return Message(content=\"\")\n\n    def update_build_config(self, build_config: dict, field_value: str, field_name: str | None = None) -> dict:\n        if field_name == \"operator\":\n            if field_value == \"regex\":\n                build_config.pop(\"case_sensitive\", None)\n            elif \"case_sensitive\" not in build_config:\n                case_sensitive_input = next(\n                    (input_field for input_field in self.inputs if input_field.name == \"case_sensitive\"), None\n                )\n                if case_sensitive_input:\n                    build_config[\"case_sensitive\"] = case_sensitive_input.to_dict()\n        return build_config\n", "fileTypes": [], "file_path": "", "password": false, "name": "code", "advanced": true, "dynamic": true, "info": "", "load_from_db": false, "title_case": false}, "default_route": {"tool_mode": false, "trace_as_metadata": true, "options": ["true_result", "false_result"], "options_metadata": [], "combobox": false, "dialog_inputs": {}, "toggle": false, "required": false, "placeholder": "", "show": true, "name": "default_route", "value": "false_result", "display_name": "Default Route", "advanced": true, "dynamic": false, "info": "The default route to take when max iterations are reached.", "title_case": false, "external_options": {}, "type": "str", "_input_type": "DropdownInput"}, "false_case_message": {"trace_as_input": true, "tool_mode": false, "trace_as_metadata": true, "load_from_db": false, "list": false, "list_add_label": "Add More", "required": false, "placeholder": "", "show": true, "name": "false_case_message", "value": "", "display_name": "Case False", "advanced": true, "input_types": ["Message"], "dynamic": false, "info": "The message to pass if the condition is False.", "title_case": false, "type": "str", "_input_type": "MessageInput"}, "input_text": {"tool_mode": false, "trace_as_input": true, "trace_as_metadata": true, "load_from_db": false, "list": false, "list_add_label": "Add More", "required": true, "placeholder": "", "show": true, "name": "input_text", "value": "", "display_name": "Text Input", "advanced": false, "input_types": ["Message"], "dynamic": false, "info": "The primary text input for the operation.", "title_case": false, "type": "str", "_input_type": "MessageTextInput"}, "match_text": {"tool_mode": false, "trace_as_input": true, "trace_as_metadata": true, "load_from_db": false, "list": false, "list_add_label": "Add More", "required": true, "placeholder": "", "show": true, "name": "match_text", "value": "True", "display_name": "Match Text", "advanced": false, "input_types": ["Message"], "dynamic": false, "info": "The text input to compare against.", "title_case": false, "type": "str", "_input_type": "MessageTextInput"}, "max_iterations": {"tool_mode": false, "trace_as_metadata": true, "list": false, "list_add_label": "Add More", "required": false, "placeholder": "", "show": true, "name": "max_iterations", "value": 10, "display_name": "Max Iterations", "advanced": true, "dynamic": false, "info": "The maximum number of iterations for the conditional router.", "title_case": false, "type": "int", "_input_type": "IntInput"}, "operator": {"tool_mode": false, "trace_as_metadata": true, "options": ["equals", "not equals", "contains", "starts with", "ends with", "regex", "less than", "less than or equal", "greater than", "greater than or equal"], "options_metadata": [], "combobox": false, "dialog_inputs": {}, "toggle": false, "required": false, "placeholder": "", "show": true, "name": "operator", "value": "equals", "display_name": "Operator", "advanced": false, "dynamic": false, "info": "The operator to apply for comparing the texts.", "real_time_refresh": true, "title_case": false, "external_options": {}, "type": "str", "_input_type": "DropdownInput"}, "true_case_message": {"trace_as_input": true, "tool_mode": false, "trace_as_metadata": true, "load_from_db": false, "list": false, "list_add_label": "Add More", "required": false, "placeholder": "", "show": true, "name": "true_case_message", "value": "", "display_name": "Case True", "advanced": true, "input_types": ["Message"], "dynamic": false, "info": "The message to pass if the condition is True.", "title_case": false, "type": "str", "_input_type": "MessageInput"}}, "description": "Routes an input message to a corresponding output based on text comparison.", "icon": "split", "base_classes": ["Message"], "display_name": "If-Else", "documentation": "https://docs.langflow.org/components-logic#conditional-router-if-else-component", "minimized": false, "custom_fields": {}, "output_types": [], "pinned": false, "conditional_paths": [], "frozen": false, "outputs": [{"types": ["Message"], "selected": "Message", "name": "true_result", "display_name": "True", "method": "true_response", "value": "__UNDEFINED__", "cache": true, "allows_loop": false, "group_outputs": true, "tool_mode": true}, {"types": ["Message"], "selected": "Message", "name": "false_result", "display_name": "False", "method": "false_response", "value": "__UNDEFINED__", "cache": true, "allows_loop": false, "group_outputs": true, "tool_mode": true}], "field_order": ["input_text", "operator", "match_text", "case_sensitive", "true_case_message", "false_case_message", "max_iterations", "default_route"], "beta": false, "legacy": false, "edited": false, "metadata": {}, "tool_mode": false, "category": "logic", "key": "ConditionalRouter", "score": 0.001, "lf_version": "1.6.3"}, "showNode": true, "type": "ConditionalRouter", "id": "ConditionalRouter-rdWpU"}, "selected": false, "measured": {"width": 320, "height": 427}, "dragging": false}, {"id": "ChatOutput-iDlsd", "type": "genericNode", "position": {"x": 2490.472382057387, "y": 2246.616315849832}, "data": {"node": {"template": {"_type": "Component", "input_value": {"trace_as_metadata": true, "list": false, "list_add_label": "Add More", "required": true, "placeholder": "", "show": true, "name": "input_value", "value": "", "display_name": "Inputs", "advanced": false, "input_types": ["Data", "DataFrame", "Message"], "dynamic": false, "info": "Message to be passed as output.", "title_case": false, "type": "other", "_input_type": "HandleInput"}, "code": {"type": "code", "required": true, "placeholder": "", "list": false, "show": true, "multiline": true, "value": "from collections.abc import Generator\nfrom typing import Any\n\nimport orjson\nfrom fastapi.encoders import jsonable_encoder\n\nfrom langflow.base.io.chat import ChatComponent\nfrom langflow.helpers.data import safe_convert\nfrom langflow.inputs.inputs import BoolInput, DropdownInput, HandleInput, MessageTextInput\nfrom langflow.schema.data import Data\nfrom langflow.schema.dataframe import DataFrame\nfrom langflow.schema.message import Message\nfrom langflow.schema.properties import Source\nfrom langflow.template.field.base import Output\nfrom langflow.utils.constants import (\n    MESSAGE_SENDER_AI,\n    MESSAGE_SENDER_NAME_AI,\n    MESSAGE_SENDER_USER,\n)\n\n\nclass ChatOutput(ChatComponent):\n    display_name = \"Chat Output\"\n    description = \"Display a chat message in the Playground.\"\n    documentation: str = \"https://docs.langflow.org/components-io#chat-output\"\n    icon = \"MessagesSquare\"\n    name = \"ChatOutput\"\n    minimized = True\n\n    inputs = [\n        HandleInput(\n            name=\"input_value\",\n            display_name=\"Inputs\",\n            info=\"Message to be passed as output.\",\n            input_types=[\"Data\", \"DataFrame\", \"Message\"],\n            required=True,\n        ),\n        BoolInput(\n            name=\"should_store_message\",\n            display_name=\"Store Messages\",\n            info=\"Store the message in the history.\",\n            value=True,\n            advanced=True,\n        ),\n        DropdownInput(\n            name=\"sender\",\n            display_name=\"Sender Type\",\n            options=[MESSAGE_SENDER_AI, MESSAGE_SENDER_USER],\n            value=MESSAGE_SENDER_AI,\n            advanced=True,\n            info=\"Type of sender.\",\n        ),\n        MessageTextInput(\n            name=\"sender_name\",\n            display_name=\"Sender Name\",\n            info=\"Name of the sender.\",\n            value=MESSAGE_SENDER_NAME_AI,\n            advanced=True,\n        ),\n        MessageTextInput(\n            name=\"session_id\",\n            display_name=\"Session ID\",\n            info=\"The session ID of the chat. If empty, the current session ID parameter will be used.\",\n            advanced=True,\n        ),\n        MessageTextInput(\n            name=\"data_template\",\n            display_name=\"Data Template\",\n            value=\"{text}\",\n            advanced=True,\n            info=\"Template to convert Data to Text. If left empty, it will be dynamically set to the Data's text key.\",\n        ),\n    ]\n    outputs = [\n        Output(\n            display_name=\"Output Message\",\n            name=\"message\",\n            method=\"message_response\",\n        ),\n    ]\n\n    def _build_source(self, id_: str | None, display_name: str | None, source: str | None) -> Source:\n        source_dict = {}\n        if id_:\n            source_dict[\"id\"] = id_\n        if display_name:\n            source_dict[\"display_name\"] = display_name\n        if source:\n            # Handle case where source is a ChatOpenAI object\n            if hasattr(source, \"model_name\"):\n                source_dict[\"source\"] = source.model_name\n            elif hasattr(source, \"model\"):\n                source_dict[\"source\"] = str(source.model)\n            else:\n                source_dict[\"source\"] = str(source)\n        return Source(**source_dict)\n\n    async def message_response(self) -> Message:\n        # First convert the input to string if needed\n        text = self.convert_to_string()\n\n        # Get source properties\n        source, icon, display_name, source_id = self.get_properties_from_source_component()\n\n        # Create or use existing Message object\n        if isinstance(self.input_value, Message):\n            message = self.input_value\n            # Update message properties\n            message.text = text\n        else:\n            message = Message(text=text)\n\n        # Set message properties\n        message.sender = self.sender\n        message.sender_name = self.sender_name\n        message.session_id = self.session_id\n        message.flow_id = self.graph.flow_id if hasattr(self, \"graph\") else None\n        message.properties.source = self._build_source(source_id, display_name, source)\n\n        # Store message if needed\n        if self.session_id and self.should_store_message:\n            stored_message = await self.send_message(message)\n            self.message.value = stored_message\n            message = stored_message\n\n        self.status = message\n        return message\n\n    def _serialize_data(self, data: Data) -> str:\n        \"\"\"Serialize Data object to JSON string.\"\"\"\n        # Convert data.data to JSON-serializable format\n        serializable_data = jsonable_encoder(data.data)\n        # Serialize with orjson, enabling pretty printing with indentation\n        json_bytes = orjson.dumps(serializable_data, option=orjson.OPT_INDENT_2)\n        # Convert bytes to string and wrap in Markdown code blocks\n        return \"```json\\n\" + json_bytes.decode(\"utf-8\") + \"\\n```\"\n\n    def _validate_input(self) -> None:\n        \"\"\"Validate the input data and raise ValueError if invalid.\"\"\"\n        if self.input_value is None:\n            msg = \"Input data cannot be None\"\n            raise ValueError(msg)\n        if isinstance(self.input_value, list) and not all(\n            isinstance(item, Message | Data | DataFrame | str) for item in self.input_value\n        ):\n            invalid_types = [\n                type(item).__name__\n                for item in self.input_value\n                if not isinstance(item, Message | Data | DataFrame | str)\n            ]\n            msg = f\"Expected Data or DataFrame or Message or str, got {invalid_types}\"\n            raise TypeError(msg)\n        if not isinstance(\n            self.input_value,\n            Message | Data | DataFrame | str | list | Generator | type(None),\n        ):\n            type_name = type(self.input_value).__name__\n            msg = f\"Expected Data or DataFrame or Message or str, Generator or None, got {type_name}\"\n            raise TypeError(msg)\n\n    def convert_to_string(self) -> str | Generator[Any, None, None]:\n        \"\"\"Convert input data to string with proper error handling.\"\"\"\n        self._validate_input()\n        if isinstance(self.input_value, list):\n            clean_data: bool = getattr(self, \"clean_data\", False)\n            return \"\\n\".join([safe_convert(item, clean_data=clean_data) for item in self.input_value])\n        if isinstance(self.input_value, Generator):\n            return self.input_value\n        return safe_convert(self.input_value)\n", "fileTypes": [], "file_path": "", "password": false, "name": "code", "advanced": true, "dynamic": true, "info": "", "load_from_db": false, "title_case": false}, "data_template": {"tool_mode": false, "trace_as_input": true, "trace_as_metadata": true, "load_from_db": false, "list": false, "list_add_label": "Add More", "required": false, "placeholder": "", "show": true, "name": "data_template", "value": "{text}", "display_name": "Data Template", "advanced": true, "input_types": ["Message"], "dynamic": false, "info": "Template to convert Data to Text. If left empty, it will be dynamically set to the Data's text key.", "title_case": false, "type": "str", "_input_type": "MessageTextInput"}, "sender": {"tool_mode": false, "trace_as_metadata": true, "options": ["Machine", "User"], "options_metadata": [], "combobox": false, "dialog_inputs": {}, "toggle": false, "required": false, "placeholder": "", "show": true, "name": "sender", "value": "Machine", "display_name": "Sender Type", "advanced": true, "dynamic": false, "info": "Type of sender.", "title_case": false, "external_options": {}, "type": "str", "_input_type": "DropdownInput"}, "sender_name": {"tool_mode": false, "trace_as_input": true, "trace_as_metadata": true, "load_from_db": false, "list": false, "list_add_label": "Add More", "required": false, "placeholder": "", "show": true, "name": "sender_name", "value": "AI", "display_name": "Sender Name", "advanced": true, "input_types": ["Message"], "dynamic": false, "info": "Name of the sender.", "title_case": false, "type": "str", "_input_type": "MessageTextInput"}, "session_id": {"tool_mode": false, "trace_as_input": true, "trace_as_metadata": true, "load_from_db": false, "list": false, "list_add_label": "Add More", "required": false, "placeholder": "", "show": true, "name": "session_id", "value": "", "display_name": "Session ID", "advanced": true, "input_types": ["Message"], "dynamic": false, "info": "The session ID of the chat. If empty, the current session ID parameter will be used.", "title_case": false, "type": "str", "_input_type": "MessageTextInput"}, "should_store_message": {"tool_mode": false, "trace_as_metadata": true, "list": false, "list_add_label": "Add More", "required": false, "placeholder": "", "show": true, "name": "should_store_message", "value": true, "display_name": "Store Messages", "advanced": true, "dynamic": false, "info": "Store the message in the history.", "title_case": false, "type": "bool", "_input_type": "BoolInput"}}, "description": "Display a chat message in the Playground.", "icon": "MessagesSquare", "base_classes": ["Message"], "display_name": "Chat Output", "documentation": "https://docs.langflow.org/components-io#chat-output", "minimized": true, "custom_fields": {}, "output_types": [], "pinned": false, "conditional_paths": [], "frozen": false, "outputs": [{"types": ["Message"], "selected": "Message", "name": "message", "display_name": "Output Message", "method": "message_response", "value": "__UNDEFINED__", "cache": true, "allows_loop": false, "group_outputs": false, "tool_mode": true}], "field_order": ["input_value", "should_store_message", "sender", "sender_name", "session_id", "data_template"], "beta": false, "legacy": false, "edited": false, "metadata": {}, "tool_mode": false, "category": "input_output", "key": "ChatOutput", "score": 0.003169567463043492}, "showNode": false, "type": "ChatOutput", "id": "ChatOutput-iDlsd"}, "selected": false, "measured": {"width": 192, "height": 48}, "dragging": false}, {"id": "CustomComponent-4L37T", "type": "genericNode", "position": {"x": 1909.3211556048893, "y": 2081.89143087647}, "data": {"node": {"template": {"_type": "Component", "result_data": {"tool_mode": false, "trace_as_metadata": true, "list": false, "list_add_label": "Add More", "trace_as_input": true, "required": false, "placeholder": "", "show": true, "name": "result_data", "value": "", "display_name": "Validator/Processor Result (Data)", "advanced": false, "input_types": ["Data"], "dynamic": false, "info": "\u041e\u0436\u0438\u0434\u0430\u0435\u0442 Data-\u043e\u0431\u044a\u0435\u043a\u0442 \u0441 \u043f\u043e\u043b\u044f\u043c\u0438: ok, errors[], warnings[], input{year,month,day}, timezone, base, target \u0438/\u0438\u043b\u0438 error, reason.", "title_case": false, "type": "other", "_input_type": "DataInput"}, "code": {"type": "code", "required": true, "placeholder": "", "list": false, "show": true, "multiline": true, "value": "import re\r\nfrom typing import Any, Dict, List\r\nfrom langflow.custom import Component\r\nfrom langflow.io import Output, StrInput, DataInput\r\nfrom langflow.schema import Data, Message\r\n\r\n\r\nclass MCPErrorFormatterMessage(Component):\r\n    display_name = \"MCP Error Formatter (to Message)\"\r\n    description = \"\u0424\u043e\u0440\u043c\u0430\u0442\u0438\u0440\u0443\u0435\u0442 \u043e\u0448\u0438\u0431\u043a\u0438/\u043f\u0440\u0435\u0434\u0443\u043f\u0440\u0435\u0436\u0434\u0435\u043d\u0438\u044f \u0438\u0437 Data \u0432 \u0435\u0434\u0438\u043d\u0443\u044e \u0441\u0442\u0440\u043e\u043a\u0443 \u0434\u043b\u044f \u043e\u0442\u0432\u0435\u0442\u0430 MCP-\u0441\u0435\u0440\u0432\u0435\u0440\u0430.\"\r\n    icon = \"Alert\"\r\n\r\n    inputs = [\r\n        StrInput(name=\"if_else_input\", display_name=\"If-else input\", input_types=[\"str\", \"Message\"]),\r\n        DataInput(\r\n            name=\"result_data\",\r\n            display_name=\"Validator/Processor Result (Data)\",\r\n            info=\"\u041e\u0436\u0438\u0434\u0430\u0435\u0442 Data-\u043e\u0431\u044a\u0435\u043a\u0442 \u0441 \u043f\u043e\u043b\u044f\u043c\u0438: ok, errors[], warnings[], input{year,month,day}, timezone, base, target \u0438/\u0438\u043b\u0438 error, reason.\",\r\n            input_types=[\"Data\"],\r\n        ),\r\n    ]\r\n\r\n    outputs = [\r\n        Output(display_name=\"Error Message\", name=\"output\", method=\"build_output\", type=\"Message\"),\r\n    ]\r\n    \r\n    def _extract_code(self, s: str) -> str | None:\r\n        m = re.search(r\"\\(([^)]+)\\)\\s*$\", s or \"\")\r\n        return m.group(1).strip() if m else None\r\n\r\n    def _safe_int_str(self, x: Any, width: int) -> str:\r\n        try:\r\n            return f\"{int(x):0{width}d}\"\r\n        except (ValueError, TypeError):\r\n            return \"?\" * width\r\n\r\n    def _normalize_str(self, s: Any) -> str:\r\n        return str(s or \"\").replace(\"\\n\", \" \").strip()\r\n\r\n    def _as_list(self, v: Any) -> List[str]:\r\n        if isinstance(v, list):\r\n            return [self._normalize_str(x) for x in v if self._normalize_str(x)]\r\n        if v is None:\r\n            return []\r\n        txt = self._normalize_str(v)\r\n        return [txt] if txt else []\r\n\r\n    def _hint(self, code: str) -> str:\r\n        code = (code or \"\").strip() or \"unknown_reason\"\r\n        hints = {\r\n            \"out_of_range\": \"\u0414\u0438\u0430\u043f\u0430\u0437\u043e\u043d \u043f\u043e\u043b\u0435\u0439 \u043d\u0435\u0432\u0435\u0440\u0435\u043d: \u0433\u043e\u0434 1-9999, \u043c\u0435\u0441\u044f\u0446 1-12, \u0434\u0435\u043d\u044c 1-31.\",\r\n            \"invalid_calendar_date\": \"\u0422\u0430\u043a\u043e\u0439 \u0434\u0430\u0442\u044b \u043d\u0435 \u0441\u0443\u0449\u0435\u0441\u0442\u0432\u0443\u0435\u0442 (\u043f\u0440\u043e\u0432\u0435\u0440\u044c\u0442\u0435 \u0447\u0438\u0441\u043b\u043e \u043c\u0435\u0441\u044f\u0446\u0430 \u0438 \u0432\u0438\u0441\u043e\u043a\u043e\u0441\u043d\u043e\u0441\u0442\u044c).\",\r\n            \"future_date\": \"\u0414\u0430\u0442\u0430 \u043d\u0435 \u043c\u043e\u0436\u0435\u0442 \u0431\u044b\u0442\u044c \u0438\u0437 \u0431\u0443\u0434\u0443\u0449\u0435\u0433\u043e \u043e\u0442\u043d\u043e\u0441\u0438\u0442\u0435\u043b\u044c\u043d\u043e \u0442\u0435\u043a\u0443\u0449\u0435\u0439 \u0434\u0430\u0442\u044b \u0432 \u0437\u0430\u0434\u0430\u043d\u043d\u043e\u0439 \u0442\u0430\u0439\u043c\u0437\u043e\u043d\u0435.\",\r\n            \"parse_error\": \"\u041d\u0435\u0432\u0435\u0440\u043d\u044b\u0439 \u0442\u0438\u043f/\u0444\u043e\u0440\u043c\u0430\u0442 \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u043e\u0432; \u043e\u0436\u0438\u0434\u0430\u044e\u0442\u0441\u044f \u0446\u0435\u043b\u044b\u0435 \u0447\u0438\u0441\u043b\u0430 \u0434\u043b\u044f \u0433\u043e\u0434\u0430, \u043c\u0435\u0441\u044f\u0446\u0430 \u0438 \u0434\u043d\u044f.\",\r\n            \"rate_not_found\": \"\u041a\u0443\u0440\u0441 \u043d\u0435 \u043d\u0430\u0439\u0434\u0435\u043d \u043d\u0430 \u0432\u044b\u0431\u0440\u0430\u043d\u043d\u0443\u044e \u0434\u0430\u0442\u0443 (\u043f\u0440\u043e\u0432\u0435\u0440\u044c\u0442\u0435 ISO \u043a\u043e\u0434\u044b \u0438 \u0434\u043e\u0441\u0442\u0443\u043f\u043d\u043e\u0441\u0442\u044c \u043f\u0443\u0431\u043b\u0438\u043a\u0430\u0446\u0438\u0438).\",\r\n            \"validation_error\": \"\u041e\u0431\u043d\u0430\u0440\u0443\u0436\u0435\u043d\u044b \u043e\u0448\u0438\u0431\u043a\u0438 \u0432\u0430\u043b\u0438\u0434\u0430\u0446\u0438\u0438 \u0432\u0445\u043e\u0434\u043d\u044b\u0445 \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u043e\u0432.\",\r\n            \"unknown_reason\": \"\u041f\u0440\u043e\u0432\u0435\u0440\u044c\u0442\u0435 \u043a\u043e\u0440\u0440\u0435\u043a\u0442\u043d\u043e\u0441\u0442\u044c \u0432\u0445\u043e\u0434\u043d\u044b\u0445 \u0434\u0430\u043d\u043d\u044b\u0445 \u0438 \u0434\u043e\u0441\u0442\u0443\u043f\u043d\u043e\u0441\u0442\u044c \u0438\u0441\u0442\u043e\u0447\u043d\u0438\u043a\u0430.\",\r\n        }\r\n        return hints.get(code, hints[\"unknown_reason\"])\r\n\r\n    def build_output(self) -> Message:\r\n        res: Dict[str, Any] = {}\r\n        if isinstance(self.result_data, Data):\r\n            res = res or (self.result_data.data or {})\r\n        elif isinstance(self.result_data, dict):\r\n            res = self.result_data\r\n\r\n        if not res:\r\n            return Message(text=\"status=error; code=input_missing; message=\u0414\u0430\u043d\u043d\u044b\u0435 \u043f\u0440\u0435\u0434\u044b\u0434\u0443\u0449\u0435\u0433\u043e \u044d\u0442\u0430\u043f\u0430 \u043d\u0435 \u043f\u043e\u043b\u0443\u0447\u0435\u043d\u044b.\")\r\n\r\n        ok = bool(res.get(\"ok\")) if res.get(\"ok\") is not None else None\r\n        base = self._normalize_str(res.get(\"base\"))\r\n        target = self._normalize_str(res.get(\"target\"))\r\n        tz = self._normalize_str(res.get(\"timezone\") or \"Europe/Moscow\")\r\n\r\n        inp = res.get(\"input\") or {}\r\n        y = self._safe_int_str(inp.get(\"year\"), 4) if isinstance(inp, dict) else \"????\"\r\n        m = self._safe_int_str(inp.get(\"month\"), 2) if isinstance(inp, dict) else \"??\"\r\n        d = self._safe_int_str(inp.get(\"day\"), 2) if isinstance(inp, dict) else \"??\"\r\n\r\n        date_requested = self._normalize_str(res.get(\"date_requested\")) if res.get(\"date_requested\") else \"\"\r\n        matched_date = self._normalize_str(res.get(\"matched_date\")) if res.get(\"matched_date\") else \"\"\r\n\r\n        errors = self._as_list(res.get(\"errors\"))\r\n        warnings = self._as_list(res.get(\"warnings\"))\r\n\r\n        reason = self._normalize_str(res.get(\"reason\"))\r\n        top_error = self._normalize_str(res.get(\"error\"))\r\n        if top_error and top_error not in errors:\r\n            errors.append(top_error)\r\n        error_codes_from_text = []\r\n        for e in errors:\r\n            c = self._extract_code(e)\r\n            if c:\r\n                error_codes_from_text.append(c)\r\n        if errors or (ok is False) or top_error or reason:\r\n            status = \"error\"\r\n            code = (\r\n                top_error or\r\n                reason or\r\n                (error_codes_from_text[0] if error_codes_from_text else \"validation_error\")\r\n            )\r\n        elif warnings:\r\n            status = \"warning\"\r\n            code = \"warnings_present\"\r\n        else:\r\n            status = \"ok\"\r\n            code = \"ok\"\r\n\r\n        hint_text = self._hint(code) if status != \"ok\" else \"OK\"\r\n\r\n        errs_str = \"[\" + \" | \".join(errors) + \"]\" if errors else \"[]\"\r\n        warns_str = \"[\" + \" | \".join(warnings) + \"]\" if warnings else \"[]\"\r\n\r\n        opt_parts = []\r\n        if base:\r\n            opt_parts.append(f\"base={base}\")\r\n        if target:\r\n            opt_parts.append(f\"target={target}\")\r\n        if date_requested:\r\n            opt_parts.append(f\"date_requested={date_requested}\")\r\n        if matched_date:\r\n            opt_parts.append(f\"matched_date={matched_date}\")\r\n\r\n        opt_suffix = (\"; \" + \"; \".join(opt_parts)) if opt_parts else \"\"\r\n\r\n        summary = (\r\n            f\"status={status}; code={code}; date={y}-{m}-{d}; tz={tz}; \"\r\n            f\"errors={errs_str}; warnings={warns_str}; message={hint_text}{opt_suffix}\"\r\n        )\r\n\r\n        return Message(text=summary)\r\n", "fileTypes": [], "file_path": "", "password": false, "name": "code", "advanced": true, "dynamic": true, "info": "", "load_from_db": false, "title_case": false}, "if_else_input": {"tool_mode": false, "trace_as_metadata": true, "load_from_db": false, "list": false, "list_add_label": "Add More", "required": false, "placeholder": "", "show": true, "name": "if_else_input", "value": "", "display_name": "If-else input", "advanced": false, "input_types": ["str", "Message"], "dynamic": false, "info": "", "title_case": false, "type": "str", "_input_type": "StrInput"}}, "description": "\u0424\u043e\u0440\u043c\u0430\u0442\u0438\u0440\u0443\u0435\u0442 \u043e\u0448\u0438\u0431\u043a\u0438/\u043f\u0440\u0435\u0434\u0443\u043f\u0440\u0435\u0436\u0434\u0435\u043d\u0438\u044f \u0438\u0437 Data \u0432 \u0435\u0434\u0438\u043d\u0443\u044e \u0441\u0442\u0440\u043e\u043a\u0443 \u0434\u043b\u044f \u043e\u0442\u0432\u0435\u0442\u0430 MCP-\u0441\u0435\u0440\u0432\u0435\u0440\u0430.", "icon": "Alert", "base_classes": ["Message"], "display_name": "MCP Error Formatter (to Message)", "documentation": "", "minimized": false, "custom_fields": {}, "output_types": [], "pinned": false, "conditional_paths": [], "frozen": false, "outputs": [{"types": ["Message"], "selected": "Message", "name": "output", "hidden": null, "display_name": "Error Message", "method": "build_output", "value": "__UNDEFINED__", "cache": true, "required_inputs": null, "allows_loop": false, "group_outputs": false, "options": null, "tool_mode": true}], "field_order": ["if_else_input", "result_data"], "beta": false, "legacy": false, "edited": true, "metadata": {}, "tool_mode": false, "lf_version": "1.6.3"}, "showNode": true, "type": "MCPErrorFormatterMessage", "id": "CustomComponent-4L37T"}, "selected": false, "measured": {"width": 320, "height": 263}, "dragging": false}, {"id": "TextOutput-7yCwt", "type": "genericNode", "position": {"x": 2351.0460968758766, "y": 2403.5000329184595}, "data": {"node": {"template": {"_type": "Component", "code": {"type": "code", "required": true, "placeholder": "", "list": false, "show": true, "multiline": true, "value": "from langflow.base.io.text import TextComponent\nfrom langflow.io import MultilineInput, Output\nfrom langflow.schema.message import Message\n\n\nclass TextOutputComponent(TextComponent):\n    display_name = \"Text Output\"\n    description = \"Sends text output via API.\"\n    documentation: str = \"https://docs.langflow.org/components-io#text-output\"\n    icon = \"type\"\n    name = \"TextOutput\"\n\n    inputs = [\n        MultilineInput(\n            name=\"input_value\",\n            display_name=\"Inputs\",\n            info=\"Text to be passed as output.\",\n        ),\n    ]\n    outputs = [\n        Output(display_name=\"Output Text\", name=\"text\", method=\"text_response\"),\n    ]\n\n    def text_response(self) -> Message:\n        message = Message(\n            text=self.input_value,\n        )\n        self.status = self.input_value\n        return message\n", "fileTypes": [], "file_path": "", "password": false, "name": "code", "advanced": true, "dynamic": true, "info": "", "load_from_db": false, "title_case": false}, "input_value": {"tool_mode": false, "trace_as_input": true, "multiline": true, "trace_as_metadata": true, "load_from_db": false, "list": false, "list_add_label": "Add More", "required": false, "placeholder": "", "show": true, "name": "input_value", "value": "", "display_name": "Inputs", "advanced": false, "input_types": ["Message"], "dynamic": false, "info": "Text to be passed as output.", "title_case": false, "copy_field": false, "type": "str", "_input_type": "MultilineInput"}}, "description": "Sends text output via API.", "icon": "type", "base_classes": ["Message"], "display_name": "Text Output", "documentation": "https://docs.langflow.org/components-io#text-output", "minimized": false, "custom_fields": {}, "output_types": [], "pinned": false, "conditional_paths": [], "frozen": false, "outputs": [{"types": ["Message"], "selected": "Message", "name": "text", "display_name": "Output Text", "method": "text_response", "value": "__UNDEFINED__", "cache": true, "allows_loop": false, "group_outputs": false, "tool_mode": true}], "field_order": ["input_value"], "beta": false, "legacy": false, "edited": false, "metadata": {}, "tool_mode": false, "category": "input_output", "key": "TextOutput", "score": 0.0026904540161865127, "lf_version": "1.6.3"}, "showNode": true, "type": "TextOutput", "id": "TextOutput-7yCwt"}, "selected": false, "measured": {"width": 320, "height": 203}}, {"id": "ParserComponent-X5CI5", "type": "genericNode", "position": {"x": 1106.61892558389, "y": 2107.6351199606424}, "data": {"node": {"template": {"_type": "Component", "input_data": {"trace_as_metadata": true, "list": false, "list_add_label": "Add More", "required": true, "placeholder": "", "show": true, "name": "input_data", "value": "", "display_name": "Data or DataFrame", "advanced": false, "input_types": ["DataFrame", "Data"], "dynamic": false, "info": "Accepts either a DataFrame or a Data object.", "title_case": false, "type": "other", "_input_type": "HandleInput"}, "code": {"type": "code", "required": true, "placeholder": "", "list": false, "show": true, "multiline": true, "value": "from langflow.custom.custom_component.component import Component\nfrom langflow.helpers.data import safe_convert\nfrom langflow.inputs.inputs import BoolInput, HandleInput, MessageTextInput, MultilineInput, TabInput\nfrom langflow.schema.data import Data\nfrom langflow.schema.dataframe import DataFrame\nfrom langflow.schema.message import Message\nfrom langflow.template.field.base import Output\n\n\nclass ParserComponent(Component):\n    display_name = \"Parser\"\n    description = \"Extracts text using a template.\"\n    documentation: str = \"https://docs.langflow.org/components-processing#parser\"\n    icon = \"braces\"\n\n    inputs = [\n        HandleInput(\n            name=\"input_data\",\n            display_name=\"Data or DataFrame\",\n            input_types=[\"DataFrame\", \"Data\"],\n            info=\"Accepts either a DataFrame or a Data object.\",\n            required=True,\n        ),\n        TabInput(\n            name=\"mode\",\n            display_name=\"Mode\",\n            options=[\"Parser\", \"Stringify\"],\n            value=\"Parser\",\n            info=\"Convert into raw string instead of using a template.\",\n            real_time_refresh=True,\n        ),\n        MultilineInput(\n            name=\"pattern\",\n            display_name=\"Template\",\n            info=(\n                \"Use variables within curly brackets to extract column values for DataFrames \"\n                \"or key values for Data.\"\n                \"For example: `Name: {Name}, Age: {Age}, Country: {Country}`\"\n            ),\n            value=\"Text: {text}\",  # Example default\n            dynamic=True,\n            show=True,\n            required=True,\n        ),\n        MessageTextInput(\n            name=\"sep\",\n            display_name=\"Separator\",\n            advanced=True,\n            value=\"\\n\",\n            info=\"String used to separate rows/items.\",\n        ),\n    ]\n\n    outputs = [\n        Output(\n            display_name=\"Parsed Text\",\n            name=\"parsed_text\",\n            info=\"Formatted text output.\",\n            method=\"parse_combined_text\",\n        ),\n    ]\n\n    def update_build_config(self, build_config, field_value, field_name=None):\n        \"\"\"Dynamically hide/show `template` and enforce requirement based on `stringify`.\"\"\"\n        if field_name == \"mode\":\n            build_config[\"pattern\"][\"show\"] = self.mode == \"Parser\"\n            build_config[\"pattern\"][\"required\"] = self.mode == \"Parser\"\n            if field_value:\n                clean_data = BoolInput(\n                    name=\"clean_data\",\n                    display_name=\"Clean Data\",\n                    info=(\n                        \"Enable to clean the data by removing empty rows and lines \"\n                        \"in each cell of the DataFrame/ Data object.\"\n                    ),\n                    value=True,\n                    advanced=True,\n                    required=False,\n                )\n                build_config[\"clean_data\"] = clean_data.to_dict()\n            else:\n                build_config.pop(\"clean_data\", None)\n\n        return build_config\n\n    def _clean_args(self):\n        \"\"\"Prepare arguments based on input type.\"\"\"\n        input_data = self.input_data\n\n        match input_data:\n            case list() if all(isinstance(item, Data) for item in input_data):\n                msg = \"List of Data objects is not supported.\"\n                raise ValueError(msg)\n            case DataFrame():\n                return input_data, None\n            case Data():\n                return None, input_data\n            case dict() if \"data\" in input_data:\n                try:\n                    if \"columns\" in input_data:  # Likely a DataFrame\n                        return DataFrame.from_dict(input_data), None\n                    # Likely a Data object\n                    return None, Data(**input_data)\n                except (TypeError, ValueError, KeyError) as e:\n                    msg = f\"Invalid structured input provided: {e!s}\"\n                    raise ValueError(msg) from e\n            case _:\n                msg = f\"Unsupported input type: {type(input_data)}. Expected DataFrame or Data.\"\n                raise ValueError(msg)\n\n    def parse_combined_text(self) -> Message:\n        \"\"\"Parse all rows/items into a single text or convert input to string if `stringify` is enabled.\"\"\"\n        # Early return for stringify option\n        if self.mode == \"Stringify\":\n            return self.convert_to_string()\n\n        df, data = self._clean_args()\n\n        lines = []\n        if df is not None:\n            for _, row in df.iterrows():\n                formatted_text = self.pattern.format(**row.to_dict())\n                lines.append(formatted_text)\n        elif data is not None:\n            formatted_text = self.pattern.format(**data.data)\n            lines.append(formatted_text)\n\n        combined_text = self.sep.join(lines)\n        self.status = combined_text\n        return Message(text=combined_text)\n\n    def convert_to_string(self) -> Message:\n        \"\"\"Convert input data to string with proper error handling.\"\"\"\n        result = \"\"\n        if isinstance(self.input_data, list):\n            result = \"\\n\".join([safe_convert(item, clean_data=self.clean_data or False) for item in self.input_data])\n        else:\n            result = safe_convert(self.input_data or False)\n        self.log(f\"Converted to string with length: {len(result)}\")\n\n        message = Message(text=result)\n        self.status = message\n        return message\n", "fileTypes": [], "file_path": "", "password": false, "name": "code", "advanced": true, "dynamic": true, "info": "", "load_from_db": false, "title_case": false}, "mode": {"tool_mode": false, "trace_as_metadata": true, "options": ["Parser", "Stringify"], "required": false, "placeholder": "", "show": true, "name": "mode", "value": "Parser", "display_name": "Mode", "advanced": false, "dynamic": false, "info": "Convert into raw string instead of using a template.", "real_time_refresh": true, "title_case": false, "type": "tab", "_input_type": "TabInput"}, "pattern": {"tool_mode": false, "trace_as_input": true, "multiline": true, "trace_as_metadata": true, "load_from_db": false, "list": false, "list_add_label": "Add More", "required": true, "placeholder": "", "show": true, "name": "pattern", "value": "{year}", "display_name": "Template", "advanced": false, "input_types": ["Message"], "dynamic": true, "info": "Use variables within curly brackets to extract column values for DataFrames or key values for Data.For example: `Name: {Name}, Age: {Age}, Country: {Country}`", "title_case": false, "copy_field": false, "type": "str", "_input_type": "MultilineInput"}, "sep": {"tool_mode": false, "trace_as_input": true, "trace_as_metadata": true, "load_from_db": false, "list": false, "list_add_label": "Add More", "required": false, "placeholder": "", "show": true, "name": "sep", "value": "\n", "display_name": "Separator", "advanced": true, "input_types": ["Message"], "dynamic": false, "info": "String used to separate rows/items.", "title_case": false, "type": "str", "_input_type": "MessageTextInput"}}, "description": "Extracts text using a template.", "icon": "braces", "base_classes": ["Message"], "display_name": "Parser", "documentation": "https://docs.langflow.org/components-processing#parser", "minimized": false, "custom_fields": {}, "output_types": [], "pinned": false, "conditional_paths": [], "frozen": false, "outputs": [{"types": ["Message"], "selected": "Message", "name": "parsed_text", "display_name": "Parsed Text", "method": "parse_combined_text", "value": "__UNDEFINED__", "cache": true, "allows_loop": false, "group_outputs": false, "tool_mode": true}], "field_order": ["input_data", "mode", "pattern", "sep"], "beta": false, "legacy": false, "edited": false, "metadata": {}, "tool_mode": false, "category": "processing", "key": "ParserComponent", "score": 2.220446049250313e-16, "lf_version": "1.6.3"}, "showNode": true, "type": "ParserComponent", "id": "ParserComponent-X5CI5"}, "selected": false, "measured": {"width": 320, "height": 327}, "dragging": false}, {"id": "ParserComponent-J9XIt", "type": "genericNode", "position": {"x": 1090.6185039195366, "y": 2465.1817980777496}, "data": {"node": {"template": {"_type": "Component", "input_data": {"trace_as_metadata": true, "list": false, "list_add_label": "Add More", "required": true, "placeholder": "", "show": true, "name": "input_data", "value": "", "display_name": "Data or DataFrame", "advanced": false, "input_types": ["DataFrame", "Data"], "dynamic": false, "info": "Accepts either a DataFrame or a Data object.", "title_case": false, "type": "other", "_input_type": "HandleInput"}, "code": {"type": "code", "required": true, "placeholder": "", "list": false, "show": true, "multiline": true, "value": "from langflow.custom.custom_component.component import Component\nfrom langflow.helpers.data import safe_convert\nfrom langflow.inputs.inputs import BoolInput, HandleInput, MessageTextInput, MultilineInput, TabInput\nfrom langflow.schema.data import Data\nfrom langflow.schema.dataframe import DataFrame\nfrom langflow.schema.message import Message\nfrom langflow.template.field.base import Output\n\n\nclass ParserComponent(Component):\n    display_name = \"Parser\"\n    description = \"Extracts text using a template.\"\n    documentation: str = \"https://docs.langflow.org/components-processing#parser\"\n    icon = \"braces\"\n\n    inputs = [\n        HandleInput(\n            name=\"input_data\",\n            display_name=\"Data or DataFrame\",\n            input_types=[\"DataFrame\", \"Data\"],\n            info=\"Accepts either a DataFrame or a Data object.\",\n            required=True,\n        ),\n        TabInput(\n            name=\"mode\",\n            display_name=\"Mode\",\n            options=[\"Parser\", \"Stringify\"],\n            value=\"Parser\",\n            info=\"Convert into raw string instead of using a template.\",\n            real_time_refresh=True,\n        ),\n        MultilineInput(\n            name=\"pattern\",\n            display_name=\"Template\",\n            info=(\n                \"Use variables within curly brackets to extract column values for DataFrames \"\n                \"or key values for Data.\"\n                \"For example: `Name: {Name}, Age: {Age}, Country: {Country}`\"\n            ),\n            value=\"Text: {text}\",  # Example default\n            dynamic=True,\n            show=True,\n            required=True,\n        ),\n        MessageTextInput(\n            name=\"sep\",\n            display_name=\"Separator\",\n            advanced=True,\n            value=\"\\n\",\n            info=\"String used to separate rows/items.\",\n        ),\n    ]\n\n    outputs = [\n        Output(\n            display_name=\"Parsed Text\",\n            name=\"parsed_text\",\n            info=\"Formatted text output.\",\n            method=\"parse_combined_text\",\n        ),\n    ]\n\n    def update_build_config(self, build_config, field_value, field_name=None):\n        \"\"\"Dynamically hide/show `template` and enforce requirement based on `stringify`.\"\"\"\n        if field_name == \"mode\":\n            build_config[\"pattern\"][\"show\"] = self.mode == \"Parser\"\n            build_config[\"pattern\"][\"required\"] = self.mode == \"Parser\"\n            if field_value:\n                clean_data = BoolInput(\n                    name=\"clean_data\",\n                    display_name=\"Clean Data\",\n                    info=(\n                        \"Enable to clean the data by removing empty rows and lines \"\n                        \"in each cell of the DataFrame/ Data object.\"\n                    ),\n                    value=True,\n                    advanced=True,\n                    required=False,\n                )\n                build_config[\"clean_data\"] = clean_data.to_dict()\n            else:\n                build_config.pop(\"clean_data\", None)\n\n        return build_config\n\n    def _clean_args(self):\n        \"\"\"Prepare arguments based on input type.\"\"\"\n        input_data = self.input_data\n\n        match input_data:\n            case list() if all(isinstance(item, Data) for item in input_data):\n                msg = \"List of Data objects is not supported.\"\n                raise ValueError(msg)\n            case DataFrame():\n                return input_data, None\n            case Data():\n                return None, input_data\n            case dict() if \"data\" in input_data:\n                try:\n                    if \"columns\" in input_data:  # Likely a DataFrame\n                        return DataFrame.from_dict(input_data), None\n                    # Likely a Data object\n                    return None, Data(**input_data)\n                except (TypeError, ValueError, KeyError) as e:\n                    msg = f\"Invalid structured input provided: {e!s}\"\n                    raise ValueError(msg) from e\n            case _:\n                msg = f\"Unsupported input type: {type(input_data)}. Expected DataFrame or Data.\"\n                raise ValueError(msg)\n\n    def parse_combined_text(self) -> Message:\n        \"\"\"Parse all rows/items into a single text or convert input to string if `stringify` is enabled.\"\"\"\n        # Early return for stringify option\n        if self.mode == \"Stringify\":\n            return self.convert_to_string()\n\n        df, data = self._clean_args()\n\n        lines = []\n        if df is not None:\n            for _, row in df.iterrows():\n                formatted_text = self.pattern.format(**row.to_dict())\n                lines.append(formatted_text)\n        elif data is not None:\n            formatted_text = self.pattern.format(**data.data)\n            lines.append(formatted_text)\n\n        combined_text = self.sep.join(lines)\n        self.status = combined_text\n        return Message(text=combined_text)\n\n    def convert_to_string(self) -> Message:\n        \"\"\"Convert input data to string with proper error handling.\"\"\"\n        result = \"\"\n        if isinstance(self.input_data, list):\n            result = \"\\n\".join([safe_convert(item, clean_data=self.clean_data or False) for item in self.input_data])\n        else:\n            result = safe_convert(self.input_data or False)\n        self.log(f\"Converted to string with length: {len(result)}\")\n\n        message = Message(text=result)\n        self.status = message\n        return message\n", "fileTypes": [], "file_path": "", "password": false, "name": "code", "advanced": true, "dynamic": true, "info": "", "load_from_db": false, "title_case": false}, "mode": {"tool_mode": false, "trace_as_metadata": true, "options": ["Parser", "Stringify"], "required": false, "placeholder": "", "show": true, "name": "mode", "value": "Parser", "display_name": "Mode", "advanced": false, "dynamic": false, "info": "Convert into raw string instead of using a template.", "real_time_refresh": true, "title_case": false, "type": "tab", "_input_type": "TabInput"}, "pattern": {"tool_mode": false, "trace_as_input": true, "multiline": true, "trace_as_metadata": true, "load_from_db": false, "list": false, "list_add_label": "Add More", "required": true, "placeholder": "", "show": true, "name": "pattern", "value": "{month}", "display_name": "Template", "advanced": false, "input_types": ["Message"], "dynamic": true, "info": "Use variables within curly brackets to extract column values for DataFrames or key values for Data.For example: `Name: {Name}, Age: {Age}, Country: {Country}`", "title_case": false, "copy_field": false, "type": "str", "_input_type": "MultilineInput"}, "sep": {"tool_mode": false, "trace_as_input": true, "trace_as_metadata": true, "load_from_db": false, "list": false, "list_add_label": "Add More", "required": false, "placeholder": "", "show": true, "name": "sep", "value": "\n", "display_name": "Separator", "advanced": true, "input_types": ["Message"], "dynamic": false, "info": "String used to separate rows/items.", "title_case": false, "type": "str", "_input_type": "MessageTextInput"}}, "description": "Extracts text using a template.", "icon": "braces", "base_classes": ["Message"], "display_name": "Parser", "documentation": "https://docs.langflow.org/components-processing#parser", "minimized": false, "custom_fields": {}, "output_types": [], "pinned": false, "conditional_paths": [], "frozen": false, "outputs": [{"types": ["Message"], "selected": "Message", "name": "parsed_text", "display_name": "Parsed Text", "method": "parse_combined_text", "value": "__UNDEFINED__", "cache": true, "allows_loop": false, "group_outputs": false, "tool_mode": true}], "field_order": ["input_data", "mode", "pattern", "sep"], "beta": false, "legacy": false, "edited": false, "metadata": {}, "tool_mode": false, "category": "processing", "key": "ParserComponent", "score": 2.220446049250313e-16, "lf_version": "1.6.3"}, "showNode": true, "type": "ParserComponent", "id": "ParserComponent-J9XIt"}, "selected": false, "measured": {"width": 320, "height": 327}, "dragging": false}, {"id": "ParserComponent-OiKHM", "type": "genericNode", "position": {"x": 1086.624955870672, "y": 2827.438057473735}, "data": {"node": {"template": {"_type": "Component", "input_data": {"trace_as_metadata": true, "list": false, "list_add_label": "Add More", "required": true, "placeholder": "", "show": true, "name": "input_data", "value": "", "display_name": "Data or DataFrame", "advanced": false, "input_types": ["DataFrame", "Data"], "dynamic": false, "info": "Accepts either a DataFrame or a Data object.", "title_case": false, "type": "other", "_input_type": "HandleInput"}, "code": {"type": "code", "required": true, "placeholder": "", "list": false, "show": true, "multiline": true, "value": "from langflow.custom.custom_component.component import Component\nfrom langflow.helpers.data import safe_convert\nfrom langflow.inputs.inputs import BoolInput, HandleInput, MessageTextInput, MultilineInput, TabInput\nfrom langflow.schema.data import Data\nfrom langflow.schema.dataframe import DataFrame\nfrom langflow.schema.message import Message\nfrom langflow.template.field.base import Output\n\n\nclass ParserComponent(Component):\n    display_name = \"Parser\"\n    description = \"Extracts text using a template.\"\n    documentation: str = \"https://docs.langflow.org/components-processing#parser\"\n    icon = \"braces\"\n\n    inputs = [\n        HandleInput(\n            name=\"input_data\",\n            display_name=\"Data or DataFrame\",\n            input_types=[\"DataFrame\", \"Data\"],\n            info=\"Accepts either a DataFrame or a Data object.\",\n            required=True,\n        ),\n        TabInput(\n            name=\"mode\",\n            display_name=\"Mode\",\n            options=[\"Parser\", \"Stringify\"],\n            value=\"Parser\",\n            info=\"Convert into raw string instead of using a template.\",\n            real_time_refresh=True,\n        ),\n        MultilineInput(\n            name=\"pattern\",\n            display_name=\"Template\",\n            info=(\n                \"Use variables within curly brackets to extract column values for DataFrames \"\n                \"or key values for Data.\"\n                \"For example: `Name: {Name}, Age: {Age}, Country: {Country}`\"\n            ),\n            value=\"Text: {text}\",  # Example default\n            dynamic=True,\n            show=True,\n            required=True,\n        ),\n        MessageTextInput(\n            name=\"sep\",\n            display_name=\"Separator\",\n            advanced=True,\n            value=\"\\n\",\n            info=\"String used to separate rows/items.\",\n        ),\n    ]\n\n    outputs = [\n        Output(\n            display_name=\"Parsed Text\",\n            name=\"parsed_text\",\n            info=\"Formatted text output.\",\n            method=\"parse_combined_text\",\n        ),\n    ]\n\n    def update_build_config(self, build_config, field_value, field_name=None):\n        \"\"\"Dynamically hide/show `template` and enforce requirement based on `stringify`.\"\"\"\n        if field_name == \"mode\":\n            build_config[\"pattern\"][\"show\"] = self.mode == \"Parser\"\n            build_config[\"pattern\"][\"required\"] = self.mode == \"Parser\"\n            if field_value:\n                clean_data = BoolInput(\n                    name=\"clean_data\",\n                    display_name=\"Clean Data\",\n                    info=(\n                        \"Enable to clean the data by removing empty rows and lines \"\n                        \"in each cell of the DataFrame/ Data object.\"\n                    ),\n                    value=True,\n                    advanced=True,\n                    required=False,\n                )\n                build_config[\"clean_data\"] = clean_data.to_dict()\n            else:\n                build_config.pop(\"clean_data\", None)\n\n        return build_config\n\n    def _clean_args(self):\n        \"\"\"Prepare arguments based on input type.\"\"\"\n        input_data = self.input_data\n\n        match input_data:\n            case list() if all(isinstance(item, Data) for item in input_data):\n                msg = \"List of Data objects is not supported.\"\n                raise ValueError(msg)\n            case DataFrame():\n                return input_data, None\n            case Data():\n                return None, input_data\n            case dict() if \"data\" in input_data:\n                try:\n                    if \"columns\" in input_data:  # Likely a DataFrame\n                        return DataFrame.from_dict(input_data), None\n                    # Likely a Data object\n                    return None, Data(**input_data)\n                except (TypeError, ValueError, KeyError) as e:\n                    msg = f\"Invalid structured input provided: {e!s}\"\n                    raise ValueError(msg) from e\n            case _:\n                msg = f\"Unsupported input type: {type(input_data)}. Expected DataFrame or Data.\"\n                raise ValueError(msg)\n\n    def parse_combined_text(self) -> Message:\n        \"\"\"Parse all rows/items into a single text or convert input to string if `stringify` is enabled.\"\"\"\n        # Early return for stringify option\n        if self.mode == \"Stringify\":\n            return self.convert_to_string()\n\n        df, data = self._clean_args()\n\n        lines = []\n        if df is not None:\n            for _, row in df.iterrows():\n                formatted_text = self.pattern.format(**row.to_dict())\n                lines.append(formatted_text)\n        elif data is not None:\n            formatted_text = self.pattern.format(**data.data)\n            lines.append(formatted_text)\n\n        combined_text = self.sep.join(lines)\n        self.status = combined_text\n        return Message(text=combined_text)\n\n    def convert_to_string(self) -> Message:\n        \"\"\"Convert input data to string with proper error handling.\"\"\"\n        result = \"\"\n        if isinstance(self.input_data, list):\n            result = \"\\n\".join([safe_convert(item, clean_data=self.clean_data or False) for item in self.input_data])\n        else:\n            result = safe_convert(self.input_data or False)\n        self.log(f\"Converted to string with length: {len(result)}\")\n\n        message = Message(text=result)\n        self.status = message\n        return message\n", "fileTypes": [], "file_path": "", "password": false, "name": "code", "advanced": true, "dynamic": true, "info": "", "load_from_db": false, "title_case": false}, "mode": {"tool_mode": false, "trace_as_metadata": true, "options": ["Parser", "Stringify"], "required": false, "placeholder": "", "show": true, "name": "mode", "value": "Parser", "display_name": "Mode", "advanced": false, "dynamic": false, "info": "Convert into raw string instead of using a template.", "real_time_refresh": true, "title_case": false, "type": "tab", "_input_type": "TabInput"}, "pattern": {"tool_mode": false, "trace_as_input": true, "multiline": true, "trace_as_metadata": true, "load_from_db": false, "list": false, "list_add_label": "Add More", "required": true, "placeholder": "", "show": true, "name": "pattern", "value": "{day}", "display_name": "Template", "advanced": false, "input_types": ["Message"], "dynamic": true, "info": "Use variables within curly brackets to extract column values for DataFrames or key values for Data.For example: `Name: {Name}, Age: {Age}, Country: {Country}`", "title_case": false, "copy_field": false, "type": "str", "_input_type": "MultilineInput"}, "sep": {"tool_mode": false, "trace_as_input": true, "trace_as_metadata": true, "load_from_db": false, "list": false, "list_add_label": "Add More", "required": false, "placeholder": "", "show": true, "name": "sep", "value": "\n", "display_name": "Separator", "advanced": true, "input_types": ["Message"], "dynamic": false, "info": "String used to separate rows/items.", "title_case": false, "type": "str", "_input_type": "MessageTextInput"}}, "description": "Extracts text using a template.", "icon": "braces", "base_classes": ["Message"], "display_name": "Parser", "documentation": "https://docs.langflow.org/components-processing#parser", "minimized": false, "custom_fields": {}, "output_types": [], "pinned": false, "conditional_paths": [], "frozen": false, "outputs": [{"types": ["Message"], "selected": "Message", "name": "parsed_text", "display_name": "Parsed Text", "method": "parse_combined_text", "value": "__UNDEFINED__", "cache": true, "allows_loop": false, "group_outputs": false, "tool_mode": true}], "field_order": ["input_data", "mode", "pattern", "sep"], "beta": false, "legacy": false, "edited": false, "metadata": {}, "tool_mode": false, "category": "processing", "key": "ParserComponent", "score": 2.220446049250313e-16, "lf_version": "1.6.3"}, "showNode": true, "type": "ParserComponent", "id": "ParserComponent-OiKHM"}, "selected": false, "measured": {"width": 320, "height": 327}, "dragging": false}, {"id": "ParserComponent-XCoyO", "type": "genericNode", "position": {"x": -212.6400384087013, "y": 2127.0649517549937}, "data": {"node": {"template": {"_type": "Component", "input_data": {"trace_as_metadata": true, "list": false, "list_add_label": "Add More", "required": true, "placeholder": "", "show": true, "name": "input_data", "value": "", "display_name": "Data or DataFrame", "advanced": false, "input_types": ["DataFrame", "Data"], "dynamic": false, "info": "Accepts either a DataFrame or a Data object.", "title_case": false, "type": "other", "_input_type": "HandleInput"}, "code": {"type": "code", "required": true, "placeholder": "", "list": false, "show": true, "multiline": true, "value": "from langflow.custom.custom_component.component import Component\nfrom langflow.helpers.data import safe_convert\nfrom langflow.inputs.inputs import BoolInput, HandleInput, MessageTextInput, MultilineInput, TabInput\nfrom langflow.schema.data import Data\nfrom langflow.schema.dataframe import DataFrame\nfrom langflow.schema.message import Message\nfrom langflow.template.field.base import Output\n\n\nclass ParserComponent(Component):\n    display_name = \"Parser\"\n    description = \"Extracts text using a template.\"\n    documentation: str = \"https://docs.langflow.org/components-processing#parser\"\n    icon = \"braces\"\n\n    inputs = [\n        HandleInput(\n            name=\"input_data\",\n            display_name=\"Data or DataFrame\",\n            input_types=[\"DataFrame\", \"Data\"],\n            info=\"Accepts either a DataFrame or a Data object.\",\n            required=True,\n        ),\n        TabInput(\n            name=\"mode\",\n            display_name=\"Mode\",\n            options=[\"Parser\", \"Stringify\"],\n            value=\"Parser\",\n            info=\"Convert into raw string instead of using a template.\",\n            real_time_refresh=True,\n        ),\n        MultilineInput(\n            name=\"pattern\",\n            display_name=\"Template\",\n            info=(\n                \"Use variables within curly brackets to extract column values for DataFrames \"\n                \"or key values for Data.\"\n                \"For example: `Name: {Name}, Age: {Age}, Country: {Country}`\"\n            ),\n            value=\"Text: {text}\",  # Example default\n            dynamic=True,\n            show=True,\n            required=True,\n        ),\n        MessageTextInput(\n            name=\"sep\",\n            display_name=\"Separator\",\n            advanced=True,\n            value=\"\\n\",\n            info=\"String used to separate rows/items.\",\n        ),\n    ]\n\n    outputs = [\n        Output(\n            display_name=\"Parsed Text\",\n            name=\"parsed_text\",\n            info=\"Formatted text output.\",\n            method=\"parse_combined_text\",\n        ),\n    ]\n\n    def update_build_config(self, build_config, field_value, field_name=None):\n        \"\"\"Dynamically hide/show `template` and enforce requirement based on `stringify`.\"\"\"\n        if field_name == \"mode\":\n            build_config[\"pattern\"][\"show\"] = self.mode == \"Parser\"\n            build_config[\"pattern\"][\"required\"] = self.mode == \"Parser\"\n            if field_value:\n                clean_data = BoolInput(\n                    name=\"clean_data\",\n                    display_name=\"Clean Data\",\n                    info=(\n                        \"Enable to clean the data by removing empty rows and lines \"\n                        \"in each cell of the DataFrame/ Data object.\"\n                    ),\n                    value=True,\n                    advanced=True,\n                    required=False,\n                )\n                build_config[\"clean_data\"] = clean_data.to_dict()\n            else:\n                build_config.pop(\"clean_data\", None)\n\n        return build_config\n\n    def _clean_args(self):\n        \"\"\"Prepare arguments based on input type.\"\"\"\n        input_data = self.input_data\n\n        match input_data:\n            case list() if all(isinstance(item, Data) for item in input_data):\n                msg = \"List of Data objects is not supported.\"\n                raise ValueError(msg)\n            case DataFrame():\n                return input_data, None\n            case Data():\n                return None, input_data\n            case dict() if \"data\" in input_data:\n                try:\n                    if \"columns\" in input_data:  # Likely a DataFrame\n                        return DataFrame.from_dict(input_data), None\n                    # Likely a Data object\n                    return None, Data(**input_data)\n                except (TypeError, ValueError, KeyError) as e:\n                    msg = f\"Invalid structured input provided: {e!s}\"\n                    raise ValueError(msg) from e\n            case _:\n                msg = f\"Unsupported input type: {type(input_data)}. Expected DataFrame or Data.\"\n                raise ValueError(msg)\n\n    def parse_combined_text(self) -> Message:\n        \"\"\"Parse all rows/items into a single text or convert input to string if `stringify` is enabled.\"\"\"\n        # Early return for stringify option\n        if self.mode == \"Stringify\":\n            return self.convert_to_string()\n\n        df, data = self._clean_args()\n\n        lines = []\n        if df is not None:\n            for _, row in df.iterrows():\n                formatted_text = self.pattern.format(**row.to_dict())\n                lines.append(formatted_text)\n        elif data is not None:\n            formatted_text = self.pattern.format(**data.data)\n            lines.append(formatted_text)\n\n        combined_text = self.sep.join(lines)\n        self.status = combined_text\n        return Message(text=combined_text)\n\n    def convert_to_string(self) -> Message:\n        \"\"\"Convert input data to string with proper error handling.\"\"\"\n        result = \"\"\n        if isinstance(self.input_data, list):\n            result = \"\\n\".join([safe_convert(item, clean_data=self.clean_data or False) for item in self.input_data])\n        else:\n            result = safe_convert(self.input_data or False)\n        self.log(f\"Converted to string with length: {len(result)}\")\n\n        message = Message(text=result)\n        self.status = message\n        return message\n", "fileTypes": [], "file_path": "", "password": false, "name": "code", "advanced": true, "dynamic": true, "info": "", "load_from_db": false, "title_case": false}, "mode": {"tool_mode": false, "trace_as_metadata": true, "options": ["Parser", "Stringify"], "required": false, "placeholder": "", "show": true, "name": "mode", "value": "Parser", "display_name": "Mode", "advanced": false, "dynamic": false, "info": "Convert into raw string instead of using a template.", "real_time_refresh": true, "title_case": false, "type": "tab", "_input_type": "TabInput"}, "pattern": {"tool_mode": false, "trace_as_input": true, "multiline": true, "trace_as_metadata": true, "load_from_db": false, "list": false, "list_add_label": "Add More", "required": true, "placeholder": "", "show": true, "name": "pattern", "value": "{base}", "display_name": "Template", "advanced": false, "input_types": ["Message"], "dynamic": true, "info": "Use variables within curly brackets to extract column values for DataFrames or key values for Data.For example: `Name: {Name}, Age: {Age}, Country: {Country}`", "title_case": false, "copy_field": false, "type": "str", "_input_type": "MultilineInput"}, "sep": {"tool_mode": false, "trace_as_input": true, "trace_as_metadata": true, "load_from_db": false, "list": false, "list_add_label": "Add More", "required": false, "placeholder": "", "show": true, "name": "sep", "value": "\n", "display_name": "Separator", "advanced": true, "input_types": ["Message"], "dynamic": false, "info": "String used to separate rows/items.", "title_case": false, "type": "str", "_input_type": "MessageTextInput"}}, "description": "Extracts text using a template.", "icon": "braces", "base_classes": ["Message"], "display_name": "Parser", "documentation": "https://docs.langflow.org/components-processing#parser", "minimized": false, "custom_fields": {}, "output_types": [], "pinned": false, "conditional_paths": [], "frozen": false, "outputs": [{"types": ["Message"], "selected": "Message", "name": "parsed_text", "display_name": "Parsed Text", "method": "parse_combined_text", "value": "__UNDEFINED__", "cache": true, "allows_loop": false, "group_outputs": false, "tool_mode": true}], "field_order": ["input_data", "mode", "pattern", "sep"], "beta": false, "legacy": false, "edited": false, "metadata": {}, "tool_mode": false, "category": "processing", "key": "ParserComponent", "score": 2.220446049250313e-16, "lf_version": "1.6.3"}, "showNode": true, "type": "ParserComponent", "id": "ParserComponent-XCoyO"}, "selected": false, "measured": {"width": 320, "height": 327}, "dragging": false}, {"id": "ParserComponent-47fqI", "type": "genericNode", "position": {"x": -214.97110354397836, "y": 2492.2977670079176}, "data": {"node": {"template": {"_type": "Component", "input_data": {"trace_as_metadata": true, "list": false, "list_add_label": "Add More", "required": true, "placeholder": "", "show": true, "name": "input_data", "value": "", "display_name": "Data or DataFrame", "advanced": false, "input_types": ["DataFrame", "Data"], "dynamic": false, "info": "Accepts either a DataFrame or a Data object.", "title_case": false, "type": "other", "_input_type": "HandleInput"}, "code": {"type": "code", "required": true, "placeholder": "", "list": false, "show": true, "multiline": true, "value": "from langflow.custom.custom_component.component import Component\nfrom langflow.helpers.data import safe_convert\nfrom langflow.inputs.inputs import BoolInput, HandleInput, MessageTextInput, MultilineInput, TabInput\nfrom langflow.schema.data import Data\nfrom langflow.schema.dataframe import DataFrame\nfrom langflow.schema.message import Message\nfrom langflow.template.field.base import Output\n\n\nclass ParserComponent(Component):\n    display_name = \"Parser\"\n    description = \"Extracts text using a template.\"\n    documentation: str = \"https://docs.langflow.org/components-processing#parser\"\n    icon = \"braces\"\n\n    inputs = [\n        HandleInput(\n            name=\"input_data\",\n            display_name=\"Data or DataFrame\",\n            input_types=[\"DataFrame\", \"Data\"],\n            info=\"Accepts either a DataFrame or a Data object.\",\n            required=True,\n        ),\n        TabInput(\n            name=\"mode\",\n            display_name=\"Mode\",\n            options=[\"Parser\", \"Stringify\"],\n            value=\"Parser\",\n            info=\"Convert into raw string instead of using a template.\",\n            real_time_refresh=True,\n        ),\n        MultilineInput(\n            name=\"pattern\",\n            display_name=\"Template\",\n            info=(\n                \"Use variables within curly brackets to extract column values for DataFrames \"\n                \"or key values for Data.\"\n                \"For example: `Name: {Name}, Age: {Age}, Country: {Country}`\"\n            ),\n            value=\"Text: {text}\",  # Example default\n            dynamic=True,\n            show=True,\n            required=True,\n        ),\n        MessageTextInput(\n            name=\"sep\",\n            display_name=\"Separator\",\n            advanced=True,\n            value=\"\\n\",\n            info=\"String used to separate rows/items.\",\n        ),\n    ]\n\n    outputs = [\n        Output(\n            display_name=\"Parsed Text\",\n            name=\"parsed_text\",\n            info=\"Formatted text output.\",\n            method=\"parse_combined_text\",\n        ),\n    ]\n\n    def update_build_config(self, build_config, field_value, field_name=None):\n        \"\"\"Dynamically hide/show `template` and enforce requirement based on `stringify`.\"\"\"\n        if field_name == \"mode\":\n            build_config[\"pattern\"][\"show\"] = self.mode == \"Parser\"\n            build_config[\"pattern\"][\"required\"] = self.mode == \"Parser\"\n            if field_value:\n                clean_data = BoolInput(\n                    name=\"clean_data\",\n                    display_name=\"Clean Data\",\n                    info=(\n                        \"Enable to clean the data by removing empty rows and lines \"\n                        \"in each cell of the DataFrame/ Data object.\"\n                    ),\n                    value=True,\n                    advanced=True,\n                    required=False,\n                )\n                build_config[\"clean_data\"] = clean_data.to_dict()\n            else:\n                build_config.pop(\"clean_data\", None)\n\n        return build_config\n\n    def _clean_args(self):\n        \"\"\"Prepare arguments based on input type.\"\"\"\n        input_data = self.input_data\n\n        match input_data:\n            case list() if all(isinstance(item, Data) for item in input_data):\n                msg = \"List of Data objects is not supported.\"\n                raise ValueError(msg)\n            case DataFrame():\n                return input_data, None\n            case Data():\n                return None, input_data\n            case dict() if \"data\" in input_data:\n                try:\n                    if \"columns\" in input_data:  # Likely a DataFrame\n                        return DataFrame.from_dict(input_data), None\n                    # Likely a Data object\n                    return None, Data(**input_data)\n                except (TypeError, ValueError, KeyError) as e:\n                    msg = f\"Invalid structured input provided: {e!s}\"\n                    raise ValueError(msg) from e\n            case _:\n                msg = f\"Unsupported input type: {type(input_data)}. Expected DataFrame or Data.\"\n                raise ValueError(msg)\n\n    def parse_combined_text(self) -> Message:\n        \"\"\"Parse all rows/items into a single text or convert input to string if `stringify` is enabled.\"\"\"\n        # Early return for stringify option\n        if self.mode == \"Stringify\":\n            return self.convert_to_string()\n\n        df, data = self._clean_args()\n\n        lines = []\n        if df is not None:\n            for _, row in df.iterrows():\n                formatted_text = self.pattern.format(**row.to_dict())\n                lines.append(formatted_text)\n        elif data is not None:\n            formatted_text = self.pattern.format(**data.data)\n            lines.append(formatted_text)\n\n        combined_text = self.sep.join(lines)\n        self.status = combined_text\n        return Message(text=combined_text)\n\n    def convert_to_string(self) -> Message:\n        \"\"\"Convert input data to string with proper error handling.\"\"\"\n        result = \"\"\n        if isinstance(self.input_data, list):\n            result = \"\\n\".join([safe_convert(item, clean_data=self.clean_data or False) for item in self.input_data])\n        else:\n            result = safe_convert(self.input_data or False)\n        self.log(f\"Converted to string with length: {len(result)}\")\n\n        message = Message(text=result)\n        self.status = message\n        return message\n", "fileTypes": [], "file_path": "", "password": false, "name": "code", "advanced": true, "dynamic": true, "info": "", "load_from_db": false, "title_case": false}, "mode": {"tool_mode": false, "trace_as_metadata": true, "options": ["Parser", "Stringify"], "required": false, "placeholder": "", "show": true, "name": "mode", "value": "Parser", "display_name": "Mode", "advanced": false, "dynamic": false, "info": "Convert into raw string instead of using a template.", "real_time_refresh": true, "title_case": false, "type": "tab", "_input_type": "TabInput"}, "pattern": {"tool_mode": false, "trace_as_input": true, "multiline": true, "trace_as_metadata": true, "load_from_db": false, "list": false, "list_add_label": "Add More", "required": true, "placeholder": "", "show": true, "name": "pattern", "value": "{target}", "display_name": "Template", "advanced": false, "input_types": ["Message"], "dynamic": true, "info": "Use variables within curly brackets to extract column values for DataFrames or key values for Data.For example: `Name: {Name}, Age: {Age}, Country: {Country}`", "title_case": false, "copy_field": false, "type": "str", "_input_type": "MultilineInput"}, "sep": {"tool_mode": false, "trace_as_input": true, "trace_as_metadata": true, "load_from_db": false, "list": false, "list_add_label": "Add More", "required": false, "placeholder": "", "show": true, "name": "sep", "value": "\n", "display_name": "Separator", "advanced": true, "input_types": ["Message"], "dynamic": false, "info": "String used to separate rows/items.", "title_case": false, "type": "str", "_input_type": "MessageTextInput"}}, "description": "Extracts text using a template.", "icon": "braces", "base_classes": ["Message"], "display_name": "Parser", "documentation": "https://docs.langflow.org/components-processing#parser", "minimized": false, "custom_fields": {}, "output_types": [], "pinned": false, "conditional_paths": [], "frozen": false, "outputs": [{"types": ["Message"], "selected": "Message", "name": "parsed_text", "display_name": "Parsed Text", "method": "parse_combined_text", "value": "__UNDEFINED__", "cache": true, "allows_loop": false, "group_outputs": false, "tool_mode": true}], "field_order": ["input_data", "mode", "pattern", "sep"], "beta": false, "legacy": false, "edited": false, "metadata": {}, "tool_mode": false, "category": "processing", "key": "ParserComponent", "score": 2.220446049250313e-16, "lf_version": "1.6.3"}, "showNode": true, "type": "ParserComponent", "id": "ParserComponent-47fqI"}, "selected": false, "measured": {"width": 320, "height": 327}, "dragging": false}, {"id": "LoadJSON-yTqey", "type": "genericNode", "position": {"x": -121.30140819841242, "y": 608.6960281873255}, "data": {"id": "LoadJSON-yTqey", "node": {"base_classes": ["Data"], "beta": false, "conditional_paths": [], "custom_fields": {}, "display_name": "Load JSON", "documentation": "", "edited": true, "field_order": ["path"], "frozen": false, "legacy": false, "lf_version": "1.6.3", "metadata": {}, "minimized": false, "output_types": [], "outputs": [{"allows_loop": false, "cache": true, "display_name": "Data", "group_outputs": false, "hidden": null, "method": "build", "name": "output", "options": null, "required_inputs": null, "selected": "Data", "tool_mode": true, "types": ["Data"], "value": "__UNDEFINED__"}], "pinned": false, "template": {"_type": "Component", "code": {"advanced": true, "dynamic": true, "fileTypes": [], "file_path": "", "info": "", "list": false, "load_from_db": false, "multiline": true, "name": "code", "password": false, "placeholder": "", "required": true, "show": true, "title_case": false, "type": "code", "value": "from langflow.custom import Component\nfrom langflow.io import StrInput, Output\nfrom langflow.schema import Data\nimport json, os\n\nclass LoadJSON(Component):\n    display_name = \"Load JSON\"\n    inputs = [\n        StrInput(name=\"path\", display_name=\"Path\", value=\"/app/data/converting.json\")\n    ]\n    outputs = [\n        Output(display_name=\"Data\", name=\"output\", method=\"build\", type=\"Data\")\n    ]\n    def build(self) -> Data:\n        path = self.path\n        if not os.path.exists(path):\n            return Data(data={\"error\": f\"not found: {path}\"})\n        with open(path, \"r\", encoding=\"utf-8\") as f:\n            obj = json.load(f)\n        return Data(data=obj)\n"}, "path": {"_input_type": "StrInput", "advanced": false, "display_name": "Path", "dynamic": false, "info": "", "list": false, "list_add_label": "Add More", "load_from_db": false, "name": "path", "placeholder": "", "required": false, "show": true, "title_case": false, "tool_mode": false, "trace_as_metadata": true, "type": "str", "value": "/app/data/converting.json"}}, "tool_mode": false}, "showNode": true, "type": "LoadJSON"}, "selected": false, "measured": {"width": 320, "height": 175}, "dragging": false}, {"id": "CustomComponent-cAc43", "type": "genericNode", "position": {"x": 685.8572123337435, "y": 1626.2254219608612}, "data": {"node": {"template": {"_type": "Component", "input_value": {"tool_mode": false, "trace_as_metadata": true, "list": false, "list_add_label": "Add More", "trace_as_input": true, "required": true, "placeholder": "", "show": true, "name": "input_value", "value": "", "display_name": "Input Data", "advanced": false, "input_types": ["Data"], "dynamic": false, "info": "\u041e\u0431\u044a\u0435\u043a\u0442 Data, \u0433\u0434\u0435 value \u2014 \u044d\u0442\u043e dict \u0438\u0437 \u043f\u0440\u0438\u043c\u0435\u0440\u0430.", "title_case": false, "type": "other", "_input_type": "DataInput"}, "code": {"type": "code", "required": true, "placeholder": "", "list": false, "show": true, "multiline": true, "value": "from typing import Any, Dict, Optional, Tuple\r\nfrom langflow.custom.custom_component.component import Component\r\nfrom langflow.io import Output, DataInput\r\nfrom langflow.schema.data import Data\r\n\r\nclass ExtractYMD(Component):\r\n    display_name = \"Extract Y/M/D\"\r\n    description = \"\u041f\u0440\u0438\u043d\u0438\u043c\u0430\u0435\u0442 Data \u0441\u043e \u0441\u0442\u0440\u0443\u043a\u0442\u0443\u0440\u043e\u0439 {'input': {'year': ..., 'month': ..., 'day': ...}} \u0438 \u0432\u043e\u0437\u0432\u0440\u0430\u0449\u0430\u0435\u0442 Data.\"  # noqa: E501\r\n    documentation: str = \"https://docs.langflow.org/components-custom-components\"\r\n    icon = \"calendar\"\r\n    name = \"extract_ymd\"\r\n\r\n\r\n    inputs = [\r\n         DataInput(\r\n             name=\"input_value\",\r\n             display_name=\"Input Data\",\r\n             info=\"\u041e\u0431\u044a\u0435\u043a\u0442 Data, \u0433\u0434\u0435 value \u2014 \u044d\u0442\u043e dict \u0438\u0437 \u043f\u0440\u0438\u043c\u0435\u0440\u0430.\",\r\n             required=True,\r\n         ),\r\n     ]\r\n\r\n\r\n\r\n    outputs = [\r\n        Output(display_name=\"date\", name=\"date\", method=\"extract_ymd\"),\r\n    ]\r\n\r\n\r\n    def extract_ymd(self) -> Data:\r\n        obj = self.input_value.data\r\n        if not isinstance(obj, dict):\r\n            self.log(\"Invalid Data to input\")\r\n            return {}\r\n        try:\r\n            date = obj.get(\"input\", {})\r\n            self.log(date)\r\n            if date == {}:\r\n                self.log(\"Invalid Data structure\")\r\n                return {}\r\n            year = int(date.get(\"year\"))\r\n            month = int(date.get(\"month\"))\r\n            day = int(date.get(\"day\"))\r\n        except Exception as E:\r\n            self.log(f\"Get error: {E}\")\r\n            return {}\r\n        \r\n        self.status = {\"year\": year, \"month\": month, \"day\": day}\r\n        return Data(data={\"year\": year, \"month\": month, \"day\": day})\r\n\r\n\r\n\r\n", "fileTypes": [], "file_path": "", "password": false, "name": "code", "advanced": true, "dynamic": true, "info": "", "load_from_db": false, "title_case": false}}, "description": "\u041f\u0440\u0438\u043d\u0438\u043c\u0430\u0435\u0442 Data \u0441\u043e \u0441\u0442\u0440\u0443\u043a\u0442\u0443\u0440\u043e\u0439 {'input': {'year': ..., 'month': ..., 'day': ...}} \u0438 \u0432\u043e\u0437\u0432\u0440\u0430\u0449\u0430\u0435\u0442 Data.", "icon": "calendar", "base_classes": ["Data"], "display_name": "Extract Y/M/D", "documentation": "https://docs.langflow.org/components-custom-components", "minimized": false, "custom_fields": {}, "output_types": [], "pinned": false, "conditional_paths": [], "frozen": false, "outputs": [{"types": ["Data"], "selected": "Data", "name": "date", "hidden": null, "display_name": "date", "method": "extract_ymd", "value": "__UNDEFINED__", "cache": true, "required_inputs": null, "allows_loop": false, "group_outputs": false, "options": null, "tool_mode": true}], "field_order": ["input_value"], "beta": false, "legacy": false, "edited": true, "metadata": {}, "tool_mode": false, "lf_version": "1.6.3"}, "showNode": true, "type": "extract_ymd", "id": "CustomComponent-cAc43", "selected_output": "year"}, "selected": false, "measured": {"width": 320, "height": 181}, "dragging": false}, {"id": "ParserComponent-3ZCGm", "type": "genericNode", "position": {"x": -215.54953863112144, "y": 2858.3830713594416}, "data": {"node": {"template": {"_type": "Component", "input_data": {"trace_as_metadata": true, "list": false, "list_add_label": "Add More", "required": true, "placeholder": "", "show": true, "name": "input_data", "value": "", "display_name": "Data or DataFrame", "advanced": false, "input_types": ["DataFrame", "Data"], "dynamic": false, "info": "Accepts either a DataFrame or a Data object.", "title_case": false, "type": "other", "_input_type": "HandleInput"}, "code": {"type": "code", "required": true, "placeholder": "", "list": false, "show": true, "multiline": true, "value": "from langflow.custom.custom_component.component import Component\nfrom langflow.helpers.data import safe_convert\nfrom langflow.inputs.inputs import BoolInput, HandleInput, MessageTextInput, MultilineInput, TabInput\nfrom langflow.schema.data import Data\nfrom langflow.schema.dataframe import DataFrame\nfrom langflow.schema.message import Message\nfrom langflow.template.field.base import Output\n\n\nclass ParserComponent(Component):\n    display_name = \"Parser\"\n    description = \"Extracts text using a template.\"\n    documentation: str = \"https://docs.langflow.org/components-processing#parser\"\n    icon = \"braces\"\n\n    inputs = [\n        HandleInput(\n            name=\"input_data\",\n            display_name=\"Data or DataFrame\",\n            input_types=[\"DataFrame\", \"Data\"],\n            info=\"Accepts either a DataFrame or a Data object.\",\n            required=True,\n        ),\n        TabInput(\n            name=\"mode\",\n            display_name=\"Mode\",\n            options=[\"Parser\", \"Stringify\"],\n            value=\"Parser\",\n            info=\"Convert into raw string instead of using a template.\",\n            real_time_refresh=True,\n        ),\n        MultilineInput(\n            name=\"pattern\",\n            display_name=\"Template\",\n            info=(\n                \"Use variables within curly brackets to extract column values for DataFrames \"\n                \"or key values for Data.\"\n                \"For example: `Name: {Name}, Age: {Age}, Country: {Country}`\"\n            ),\n            value=\"Text: {text}\",  # Example default\n            dynamic=True,\n            show=True,\n            required=True,\n        ),\n        MessageTextInput(\n            name=\"sep\",\n            display_name=\"Separator\",\n            advanced=True,\n            value=\"\\n\",\n            info=\"String used to separate rows/items.\",\n        ),\n    ]\n\n    outputs = [\n        Output(\n            display_name=\"Parsed Text\",\n            name=\"parsed_text\",\n            info=\"Formatted text output.\",\n            method=\"parse_combined_text\",\n        ),\n    ]\n\n    def update_build_config(self, build_config, field_value, field_name=None):\n        \"\"\"Dynamically hide/show `template` and enforce requirement based on `stringify`.\"\"\"\n        if field_name == \"mode\":\n            build_config[\"pattern\"][\"show\"] = self.mode == \"Parser\"\n            build_config[\"pattern\"][\"required\"] = self.mode == \"Parser\"\n            if field_value:\n                clean_data = BoolInput(\n                    name=\"clean_data\",\n                    display_name=\"Clean Data\",\n                    info=(\n                        \"Enable to clean the data by removing empty rows and lines \"\n                        \"in each cell of the DataFrame/ Data object.\"\n                    ),\n                    value=True,\n                    advanced=True,\n                    required=False,\n                )\n                build_config[\"clean_data\"] = clean_data.to_dict()\n            else:\n                build_config.pop(\"clean_data\", None)\n\n        return build_config\n\n    def _clean_args(self):\n        \"\"\"Prepare arguments based on input type.\"\"\"\n        input_data = self.input_data\n\n        match input_data:\n            case list() if all(isinstance(item, Data) for item in input_data):\n                msg = \"List of Data objects is not supported.\"\n                raise ValueError(msg)\n            case DataFrame():\n                return input_data, None\n            case Data():\n                return None, input_data\n            case dict() if \"data\" in input_data:\n                try:\n                    if \"columns\" in input_data:  # Likely a DataFrame\n                        return DataFrame.from_dict(input_data), None\n                    # Likely a Data object\n                    return None, Data(**input_data)\n                except (TypeError, ValueError, KeyError) as e:\n                    msg = f\"Invalid structured input provided: {e!s}\"\n                    raise ValueError(msg) from e\n            case _:\n                msg = f\"Unsupported input type: {type(input_data)}. Expected DataFrame or Data.\"\n                raise ValueError(msg)\n\n    def parse_combined_text(self) -> Message:\n        \"\"\"Parse all rows/items into a single text or convert input to string if `stringify` is enabled.\"\"\"\n        # Early return for stringify option\n        if self.mode == \"Stringify\":\n            return self.convert_to_string()\n\n        df, data = self._clean_args()\n\n        lines = []\n        if df is not None:\n            for _, row in df.iterrows():\n                formatted_text = self.pattern.format(**row.to_dict())\n                lines.append(formatted_text)\n        elif data is not None:\n            formatted_text = self.pattern.format(**data.data)\n            lines.append(formatted_text)\n\n        combined_text = self.sep.join(lines)\n        self.status = combined_text\n        return Message(text=combined_text)\n\n    def convert_to_string(self) -> Message:\n        \"\"\"Convert input data to string with proper error handling.\"\"\"\n        result = \"\"\n        if isinstance(self.input_data, list):\n            result = \"\\n\".join([safe_convert(item, clean_data=self.clean_data or False) for item in self.input_data])\n        else:\n            result = safe_convert(self.input_data or False)\n        self.log(f\"Converted to string with length: {len(result)}\")\n\n        message = Message(text=result)\n        self.status = message\n        return message\n", "fileTypes": [], "file_path": "", "password": false, "name": "code", "advanced": true, "dynamic": true, "info": "", "load_from_db": false, "title_case": false}, "mode": {"tool_mode": false, "trace_as_metadata": true, "options": ["Parser", "Stringify"], "required": false, "placeholder": "", "show": true, "name": "mode", "value": "Parser", "display_name": "Mode", "advanced": false, "dynamic": false, "info": "Convert into raw string instead of using a template.", "real_time_refresh": true, "title_case": false, "type": "tab", "_input_type": "TabInput"}, "pattern": {"tool_mode": false, "trace_as_input": true, "multiline": true, "trace_as_metadata": true, "load_from_db": false, "list": false, "list_add_label": "Add More", "required": true, "placeholder": "", "show": true, "name": "pattern", "value": "{amount}", "display_name": "Template", "advanced": false, "input_types": ["Message"], "dynamic": true, "info": "Use variables within curly brackets to extract column values for DataFrames or key values for Data.For example: `Name: {Name}, Age: {Age}, Country: {Country}`", "title_case": false, "copy_field": false, "type": "str", "_input_type": "MultilineInput"}, "sep": {"tool_mode": false, "trace_as_input": true, "trace_as_metadata": true, "load_from_db": false, "list": false, "list_add_label": "Add More", "required": false, "placeholder": "", "show": true, "name": "sep", "value": "\n", "display_name": "Separator", "advanced": true, "input_types": ["Message"], "dynamic": false, "info": "String used to separate rows/items.", "title_case": false, "type": "str", "_input_type": "MessageTextInput"}}, "description": "Extracts text using a template.", "icon": "braces", "base_classes": ["Message"], "display_name": "Parser", "documentation": "https://docs.langflow.org/components-processing#parser", "minimized": false, "custom_fields": {}, "output_types": [], "pinned": false, "conditional_paths": [], "frozen": false, "outputs": [{"types": ["Message"], "selected": "Message", "name": "parsed_text", "display_name": "Parsed Text", "method": "parse_combined_text", "value": "__UNDEFINED__", "cache": true, "allows_loop": false, "group_outputs": false, "tool_mode": true}], "field_order": ["input_data", "mode", "pattern", "sep"], "beta": false, "legacy": false, "edited": false, "metadata": {}, "tool_mode": false, "category": "processing", "key": "ParserComponent", "score": 2.220446049250313e-16, "lf_version": "1.6.3"}, "showNode": true, "type": "ParserComponent", "id": "ParserComponent-3ZCGm"}, "selected": false, "measured": {"width": 320, "height": 327}, "dragging": false}, {"id": "CustomComponent-IdtOy", "type": "genericNode", "position": {"x": 2706.0611153731315, "y": 1538.589773339669}, "data": {"node": {"template": {"_type": "Component", "code": {"type": "code", "required": true, "placeholder": "", "list": false, "show": true, "multiline": true, "value": "from __future__ import annotations\r\nfrom typing import Any, Dict\r\nimport json\r\n\r\nfrom langflow.custom import Component\r\nfrom langflow.io import (\r\n    StrInput,\r\n    MessageTextInput,\r\n    BoolInput,\r\n    Output,\r\n)\r\nfrom langflow.schema import Data\r\n\r\n\r\nclass CBRMessageFormatter(Component):\r\n    display_name = \"CBR Message Formatter\"\r\n    description = \"\u0424\u043e\u0440\u043c\u0438\u0440\u0443\u0435\u0442 \u0435\u0434\u0438\u043d\u0443\u044e \u0441\u0442\u0440\u043e\u043a\u0443 \u0434\u043b\u044f Chat Output: \u0443\u0441\u043f\u0435\u0445 \u0438\u043b\u0438 \u043e\u0448\u0438\u0431\u043a\u0430 \u0441 \u0434\u0430\u0442\u0430\u043c\u0438 \u0437\u0430\u043f\u0440\u043e\u0441\u0430 \u0438 \u043a\u043e\u0442\u0438\u0440\u043e\u0432\u043a\u0438.\"\r\n    documentation = \"https://www.cbr-xml-daily.ru/\"\r\n    icon = \"Message\"\r\n\r\n    inputs = [\r\n        StrInput(\r\n            name=\"payload\",\r\n            display_name=\"Payload from previous node\",\r\n            input_types=[\"Data\", \"str\", \"Message\"],\r\n        ),\r\n        BoolInput(name=\"include_source\", display_name=\"Include source\", value=True, advanced=True),\r\n        MessageTextInput(name=\"error_prefix\", display_name=\"Error prefix\", value=\"\u041e\u0448\u0438\u0431\u043a\u0430\", advanced=True),\r\n    ]\r\n\r\n    outputs = [\r\n        Output(display_name=\"Message\", name=\"output\", method=\"build_output\", type=\"Message\"),\r\n    ]\r\n\r\n    # --- helpers ---\r\n    def _as_dict(self, obj: Any) -> Dict[str, Any]:\r\n        if isinstance(obj, Data):\r\n            return obj.data or {}\r\n        if hasattr(obj, \"data\") and isinstance(getattr(obj, \"data\"), dict):\r\n            return getattr(obj, \"data\") or {}\r\n        if isinstance(obj, dict):\r\n            return obj\r\n        if isinstance(obj, str):\r\n            s = obj.strip()\r\n            if s.startswith(\"{\") and s.endswith(\"}\"):\r\n                try:\r\n                    return json.loads(s)\r\n                except Exception:\r\n                    return {}\r\n            return {}\r\n        # Fallback\r\n        return {}\r\n\r\n    def build_output(self) -> Message:\r\n        raw = getattr(self, \"payload\", None)\r\n        data = self._as_dict(raw)\r\n\r\n        # Extract common fields with safe defaults\r\n        date_requested = data.get(\"date_requested\") or data.get(\"requested_date\") or \"unknown\"\r\n        matched_date = data.get(\"matched_date\") or data.get(\"matched\") or \"unknown\"\r\n        base = (data.get(\"base\") or \"UNKNOWN\").upper()\r\n        target = (data.get(\"target\") or \"UNKNOWN\").upper()\r\n        amount = data.get(\"amount\")\r\n        rate = data.get(\"rate\")\r\n        converted = data.get(\"converted_amount\")\r\n        error = data.get(\"error\")\r\n        have_base = data.get(\"have_base\")\r\n        have_target = data.get(\"have_target\")\r\n        codes = data.get(\"codes\") or []\r\n        source = data.get(\"source\") or \"unknown\"\r\n\r\n        include_source = bool(getattr(self, \"include_source\", True))\r\n        error_prefix = getattr(self, \"error_prefix\", \"\u041e\u0448\u0438\u0431\u043a\u0430\")\r\n\r\n        # Error / empty cases\r\n        is_empty = not bool(data)\r\n        is_rate_missing = (error is not None) or (rate is None) or (converted is None)\r\n\r\n        if is_empty or is_rate_missing:\r\n            # Build diagnostic string\r\n            diag_parts = []\r\n            diag_parts.append(f\"\u0437\u0430\u043f\u0440\u043e\u0448\u0435\u043d\u043d\u0430\u044f \u0434\u0430\u0442\u0430: {date_requested}\")\r\n            diag_parts.append(f\"\u0434\u0430\u0442\u0430 \u043a\u043e\u0442\u0438\u0440\u043e\u0432\u043a\u0438: {matched_date}\")\r\n            diag_parts.append(f\"\u043f\u0430\u0440\u0430: {base}->{target}\")\r\n            if have_base is not None and have_target is not None:\r\n                diag_parts.append(f\"have_base={have_base}, have_target={have_target}\")\r\n            if codes:\r\n                # Show only a small sample to keep message short\r\n                sample = codes[:8]\r\n                diag_parts.append(f\"codes_sample={sample}\")\r\n            if include_source and source:\r\n                diag_parts.append(f\"\u0438\u0441\u0442\u043e\u0447\u043d\u0438\u043a: {source}\")\r\n\r\n            reason = f\"{error}\" if error else \"rate_not_found\"\r\n            return f\"{error_prefix}: \u043d\u0435 \u0443\u0434\u0430\u043b\u043e\u0441\u044c \u043f\u043e\u043b\u0443\u0447\u0438\u0442\u044c \u043a\u0443\u0440\u0441 ({reason}); \" + \"; \".join(diag_parts)\r\n\r\n        # Success case\r\n        try:\r\n            amount_f = float(amount) if amount is not None else None\r\n            rate_f = float(rate) if rate is not None else None\r\n            converted_f = float(converted) if converted is not None else None\r\n        except Exception:\r\n            # Fallback to generic error if casting failed\r\n            reason = \"format_error\"\r\n            return f\"{error_prefix}: \u043d\u0435 \u0443\u0434\u0430\u043b\u043e\u0441\u044c \u0441\u0444\u043e\u0440\u043c\u0438\u0440\u043e\u0432\u0430\u0442\u044c \u043e\u0442\u0432\u0435\u0442 ({reason}); \u0437\u0430\u043f\u0440\u043e\u0448\u0435\u043d\u043d\u0430\u044f \u0434\u0430\u0442\u0430: {date_requested}; \u0434\u0430\u0442\u0430 \u043a\u043e\u0442\u0438\u0440\u043e\u0432\u043a\u0438: {matched_date}; \u043f\u0430\u0440\u0430: {base}->{target}\"\r\n\r\n        # Format numbers\r\n        amount_str = f\"{amount_f:.2f}\" if amount_f is not None else \"N/A\"\r\n        rate_str = f\"{rate_f:.6f}\" if rate_f is not None else \"N/A\"\r\n        converted_str = f\"{converted_f:.4f}\" if converted_f is not None else \"N/A\"\r\n        \r\n        # Final success message with explicit dates\r\n        msg = (\r\n            f\"{amount_str} {base} = {converted_str} {target} \"\r\n            f\"(\u043a\u0443\u0440\u0441 {rate_str}); \"\r\n            f\"\u0437\u0430\u043f\u0440\u043e\u0448\u0435\u043d\u043d\u0430\u044f \u0434\u0430\u0442\u0430: {date_requested}; \"\r\n            f\"\u0434\u0430\u0442\u0430 \u043a\u043e\u0442\u0438\u0440\u043e\u0432\u043a\u0438: {matched_date}\"\r\n        )\r\n        if date_requested != matched_date:\r\n            msg += \"; \u0432\u043d\u0438\u043c\u0430\u043d\u0438\u0435: \u0437\u0430\u043f\u0440\u043e\u0448\u0435\u043d\u043d\u0430\u044f \u0434\u0430\u0442\u0430 \u043e\u0442\u043b\u0438\u0447\u0430\u0435\u0442\u0441\u044f \u043e\u0442 \u0434\u0430\u0442\u044b \u043a\u043e\u0442\u0438\u0440\u043e\u0432\u043a\u0438: \u043d\u0430 \u0437\u0430\u043f\u0440\u043e\u0448\u0435\u043d\u043d\u0443\u044e \u0434\u0430\u0442\u0443 \u043d\u0435\u0442 \u0438\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u0438 \u043e \u043a\u0443\u0440\u0441\u0435 \u0432\u0430\u043b\u044e\u0442\"\r\n        if include_source and source:\r\n            msg += f\"; \u0438\u0441\u0442\u043e\u0447\u043d\u0438\u043a: {source}\"\r\n        return Message(text=msg)\r\n", "fileTypes": [], "file_path": "", "password": false, "name": "code", "advanced": true, "dynamic": true, "info": "", "load_from_db": false, "title_case": false}, "error_prefix": {"tool_mode": false, "trace_as_input": true, "trace_as_metadata": true, "load_from_db": false, "list": false, "list_add_label": "Add More", "required": false, "placeholder": "", "show": true, "name": "error_prefix", "value": "\u041e\u0448\u0438\u0431\u043a\u0430", "display_name": "Error prefix", "advanced": true, "input_types": ["Message"], "dynamic": false, "info": "", "title_case": false, "type": "str", "_input_type": "MessageTextInput"}, "include_source": {"tool_mode": false, "trace_as_metadata": true, "list": false, "list_add_label": "Add More", "required": false, "placeholder": "", "show": true, "name": "include_source", "value": false, "display_name": "Include source", "advanced": false, "dynamic": false, "info": "", "title_case": false, "type": "bool", "_input_type": "BoolInput"}, "payload": {"tool_mode": false, "trace_as_metadata": true, "load_from_db": false, "list": false, "list_add_label": "Add More", "required": false, "placeholder": "", "show": true, "name": "payload", "value": "", "display_name": "Payload from previous node", "advanced": false, "input_types": ["Data", "str", "Message"], "dynamic": false, "info": "", "title_case": false, "type": "str", "_input_type": "StrInput"}}, "description": "\u0424\u043e\u0440\u043c\u0438\u0440\u0443\u0435\u0442 \u0435\u0434\u0438\u043d\u0443\u044e \u0441\u0442\u0440\u043e\u043a\u0443 \u0434\u043b\u044f Chat Output: \u0443\u0441\u043f\u0435\u0445 \u0438\u043b\u0438 \u043e\u0448\u0438\u0431\u043a\u0430 \u0441 \u0434\u0430\u0442\u0430\u043c\u0438 \u0437\u0430\u043f\u0440\u043e\u0441\u0430 \u0438 \u043a\u043e\u0442\u0438\u0440\u043e\u0432\u043a\u0438.", "icon": "Message", "base_classes": ["Message"], "display_name": "CBR Message Formatter", "documentation": "https://www.cbr-xml-daily.ru/", "minimized": false, "custom_fields": {}, "output_types": [], "pinned": false, "conditional_paths": [], "frozen": false, "outputs": [{"types": ["Message"], "selected": "Message", "name": "output", "hidden": null, "display_name": "Message", "method": "build_output", "value": "__UNDEFINED__", "cache": true, "required_inputs": null, "allows_loop": false, "group_outputs": false, "options": null, "tool_mode": true}], "field_order": ["payload", "include_source", "error_prefix"], "beta": false, "legacy": false, "edited": true, "metadata": {}, "tool_mode": false, "lf_version": "1.6.3"}, "showNode": true, "type": "CBRMessageFormatter", "id": "CustomComponent-IdtOy"}, "selected": false, "measured": {"width": 320, "height": 277}, "dragging": false}, {"id": "ChatOutput-TKTFg", "type": "genericNode", "position": {"x": 3202.0298326344105, "y": 1709.4464916232914}, "data": {"node": {"template": {"_type": "Component", "input_value": {"trace_as_metadata": true, "list": false, "list_add_label": "Add More", "required": true, "placeholder": "", "show": true, "name": "input_value", "value": "", "display_name": "Inputs", "advanced": false, "input_types": ["Data", "DataFrame", "Message"], "dynamic": false, "info": "Message to be passed as output.", "title_case": false, "type": "other", "_input_type": "HandleInput"}, "code": {"type": "code", "required": true, "placeholder": "", "list": false, "show": true, "multiline": true, "value": "from collections.abc import Generator\nfrom typing import Any\n\nimport orjson\nfrom fastapi.encoders import jsonable_encoder\n\nfrom langflow.base.io.chat import ChatComponent\nfrom langflow.helpers.data import safe_convert\nfrom langflow.inputs.inputs import BoolInput, DropdownInput, HandleInput, MessageTextInput\nfrom langflow.schema.data import Data\nfrom langflow.schema.dataframe import DataFrame\nfrom langflow.schema.message import Message\nfrom langflow.schema.properties import Source\nfrom langflow.template.field.base import Output\nfrom langflow.utils.constants import (\n    MESSAGE_SENDER_AI,\n    MESSAGE_SENDER_NAME_AI,\n    MESSAGE_SENDER_USER,\n)\n\n\nclass ChatOutput(ChatComponent):\n    display_name = \"Chat Output\"\n    description = \"Display a chat message in the Playground.\"\n    documentation: str = \"https://docs.langflow.org/components-io#chat-output\"\n    icon = \"MessagesSquare\"\n    name = \"ChatOutput\"\n    minimized = True\n\n    inputs = [\n        HandleInput(\n            name=\"input_value\",\n            display_name=\"Inputs\",\n            info=\"Message to be passed as output.\",\n            input_types=[\"Data\", \"DataFrame\", \"Message\"],\n            required=True,\n        ),\n        BoolInput(\n            name=\"should_store_message\",\n            display_name=\"Store Messages\",\n            info=\"Store the message in the history.\",\n            value=True,\n            advanced=True,\n        ),\n        DropdownInput(\n            name=\"sender\",\n            display_name=\"Sender Type\",\n            options=[MESSAGE_SENDER_AI, MESSAGE_SENDER_USER],\n            value=MESSAGE_SENDER_AI,\n            advanced=True,\n            info=\"Type of sender.\",\n        ),\n        MessageTextInput(\n            name=\"sender_name\",\n            display_name=\"Sender Name\",\n            info=\"Name of the sender.\",\n            value=MESSAGE_SENDER_NAME_AI,\n            advanced=True,\n        ),\n        MessageTextInput(\n            name=\"session_id\",\n            display_name=\"Session ID\",\n            info=\"The session ID of the chat. If empty, the current session ID parameter will be used.\",\n            advanced=True,\n        ),\n        MessageTextInput(\n            name=\"data_template\",\n            display_name=\"Data Template\",\n            value=\"{text}\",\n            advanced=True,\n            info=\"Template to convert Data to Text. If left empty, it will be dynamically set to the Data's text key.\",\n        ),\n    ]\n    outputs = [\n        Output(\n            display_name=\"Output Message\",\n            name=\"message\",\n            method=\"message_response\",\n        ),\n    ]\n\n    def _build_source(self, id_: str | None, display_name: str | None, source: str | None) -> Source:\n        source_dict = {}\n        if id_:\n            source_dict[\"id\"] = id_\n        if display_name:\n            source_dict[\"display_name\"] = display_name\n        if source:\n            # Handle case where source is a ChatOpenAI object\n            if hasattr(source, \"model_name\"):\n                source_dict[\"source\"] = source.model_name\n            elif hasattr(source, \"model\"):\n                source_dict[\"source\"] = str(source.model)\n            else:\n                source_dict[\"source\"] = str(source)\n        return Source(**source_dict)\n\n    async def message_response(self) -> Message:\n        # First convert the input to string if needed\n        text = self.convert_to_string()\n\n        # Get source properties\n        source, icon, display_name, source_id = self.get_properties_from_source_component()\n\n        # Create or use existing Message object\n        if isinstance(self.input_value, Message):\n            message = self.input_value\n            # Update message properties\n            message.text = text\n        else:\n            message = Message(text=text)\n\n        # Set message properties\n        message.sender = self.sender\n        message.sender_name = self.sender_name\n        message.session_id = self.session_id\n        message.flow_id = self.graph.flow_id if hasattr(self, \"graph\") else None\n        message.properties.source = self._build_source(source_id, display_name, source)\n\n        # Store message if needed\n        if self.session_id and self.should_store_message:\n            stored_message = await self.send_message(message)\n            self.message.value = stored_message\n            message = stored_message\n\n        self.status = message\n        return message\n\n    def _serialize_data(self, data: Data) -> str:\n        \"\"\"Serialize Data object to JSON string.\"\"\"\n        # Convert data.data to JSON-serializable format\n        serializable_data = jsonable_encoder(data.data)\n        # Serialize with orjson, enabling pretty printing with indentation\n        json_bytes = orjson.dumps(serializable_data, option=orjson.OPT_INDENT_2)\n        # Convert bytes to string and wrap in Markdown code blocks\n        return \"```json\\n\" + json_bytes.decode(\"utf-8\") + \"\\n```\"\n\n    def _validate_input(self) -> None:\n        \"\"\"Validate the input data and raise ValueError if invalid.\"\"\"\n        if self.input_value is None:\n            msg = \"Input data cannot be None\"\n            raise ValueError(msg)\n        if isinstance(self.input_value, list) and not all(\n            isinstance(item, Message | Data | DataFrame | str) for item in self.input_value\n        ):\n            invalid_types = [\n                type(item).__name__\n                for item in self.input_value\n                if not isinstance(item, Message | Data | DataFrame | str)\n            ]\n            msg = f\"Expected Data or DataFrame or Message or str, got {invalid_types}\"\n            raise TypeError(msg)\n        if not isinstance(\n            self.input_value,\n            Message | Data | DataFrame | str | list | Generator | type(None),\n        ):\n            type_name = type(self.input_value).__name__\n            msg = f\"Expected Data or DataFrame or Message or str, Generator or None, got {type_name}\"\n            raise TypeError(msg)\n\n    def convert_to_string(self) -> str | Generator[Any, None, None]:\n        \"\"\"Convert input data to string with proper error handling.\"\"\"\n        self._validate_input()\n        if isinstance(self.input_value, list):\n            clean_data: bool = getattr(self, \"clean_data\", False)\n            return \"\\n\".join([safe_convert(item, clean_data=clean_data) for item in self.input_value])\n        if isinstance(self.input_value, Generator):\n            return self.input_value\n        return safe_convert(self.input_value)\n", "fileTypes": [], "file_path": "", "password": false, "name": "code", "advanced": true, "dynamic": true, "info": "", "load_from_db": false, "title_case": false}, "data_template": {"tool_mode": false, "trace_as_input": true, "trace_as_metadata": true, "load_from_db": false, "list": false, "list_add_label": "Add More", "required": false, "placeholder": "", "show": true, "name": "data_template", "value": "{text}", "display_name": "Data Template", "advanced": true, "input_types": ["Message"], "dynamic": false, "info": "Template to convert Data to Text. If left empty, it will be dynamically set to the Data's text key.", "title_case": false, "type": "str", "_input_type": "MessageTextInput"}, "sender": {"tool_mode": false, "trace_as_metadata": true, "options": ["Machine", "User"], "options_metadata": [], "combobox": false, "dialog_inputs": {}, "toggle": false, "required": false, "placeholder": "", "show": true, "name": "sender", "value": "Machine", "display_name": "Sender Type", "advanced": true, "dynamic": false, "info": "Type of sender.", "title_case": false, "external_options": {}, "type": "str", "_input_type": "DropdownInput"}, "sender_name": {"tool_mode": false, "trace_as_input": true, "trace_as_metadata": true, "load_from_db": false, "list": false, "list_add_label": "Add More", "required": false, "placeholder": "", "show": true, "name": "sender_name", "value": "AI", "display_name": "Sender Name", "advanced": true, "input_types": ["Message"], "dynamic": false, "info": "Name of the sender.", "title_case": false, "type": "str", "_input_type": "MessageTextInput"}, "session_id": {"tool_mode": false, "trace_as_input": true, "trace_as_metadata": true, "load_from_db": false, "list": false, "list_add_label": "Add More", "required": false, "placeholder": "", "show": true, "name": "session_id", "value": "", "display_name": "Session ID", "advanced": true, "input_types": ["Message"], "dynamic": false, "info": "The session ID of the chat. If empty, the current session ID parameter will be used.", "title_case": false, "type": "str", "_input_type": "MessageTextInput"}, "should_store_message": {"tool_mode": false, "trace_as_metadata": true, "list": false, "list_add_label": "Add More", "required": false, "placeholder": "", "show": true, "name": "should_store_message", "value": true, "display_name": "Store Messages", "advanced": true, "dynamic": false, "info": "Store the message in the history.", "title_case": false, "type": "bool", "_input_type": "BoolInput"}}, "description": "Display a chat message in the Playground.", "icon": "MessagesSquare", "base_classes": ["Message"], "display_name": "Chat Output", "documentation": "https://docs.langflow.org/components-io#chat-output", "minimized": true, "custom_fields": {}, "output_types": [], "pinned": false, "conditional_paths": [], "frozen": false, "outputs": [{"types": ["Message"], "selected": "Message", "name": "message", "display_name": "Output Message", "method": "message_response", "value": "__UNDEFINED__", "cache": true, "allows_loop": false, "group_outputs": false, "tool_mode": true}], "field_order": ["input_value", "should_store_message", "sender", "sender_name", "session_id", "data_template"], "beta": false, "legacy": false, "edited": false, "metadata": {}, "tool_mode": false, "lf_version": "1.6.3"}, "showNode": false, "type": "ChatOutput", "id": "ChatOutput-TKTFg"}, "selected": false, "measured": {"width": 192, "height": 48}, "dragging": false}, {"id": "CustomComponent-ttERH", "type": "genericNode", "position": {"x": 811.462898962178, "y": 820.3581199441875}, "data": {"node": {"template": {"_type": "Component", "input_value": {"tool_mode": false, "trace_as_metadata": true, "list": false, "list_add_label": "Add More", "trace_as_input": true, "required": true, "placeholder": "", "show": true, "name": "input_value", "value": "", "display_name": "Input Data", "advanced": false, "input_types": ["Data"], "dynamic": false, "info": "\u041e\u0431\u044a\u0435\u043a\u0442 Data , \u0433\u0434\u0435 value \u2014 \u044d\u0442\u043e dict \u0438\u0437 \u043f\u0440\u0438\u043c\u0435\u0440\u0430.", "title_case": false, "type": "other", "_input_type": "DataInput"}, "code": {"type": "code", "required": true, "placeholder": "", "list": false, "show": true, "multiline": true, "value": "from typing import Any, Dict, Optional, Tuple\r\nfrom langflow.custom.custom_component.component import Component\r\nfrom langflow.io import Output, DataInput\r\nfrom langflow.schema.data import Data\r\n\r\nclass ExtractCodes(Component):\r\n    display_name = \"Extract base and target codes\"\r\n    description = \"\u041f\u0440\u0438\u043d\u0438\u043c\u0430\u0435\u0442 Data \u0441\u043e \u0441\u0442\u0440\u0443\u043a\u0442\u0443\u0440\u043e\u0439 {'normalized': {'base': ..., 'target': ...}} \u0438 \u0432\u043e\u0437\u0432\u0440\u0430\u0449\u0430\u0435\u0442 Data.\"  # noqa: E501\r\n    documentation: str = \"https://docs.langflow.org/components-custom-components\"\r\n    icon = \"calendar\"\r\n    name = \"extract_codes\"\r\n\r\n\r\n    inputs = [\r\n         DataInput(\r\n             name=\"input_value\",\r\n             display_name=\"Input Data\",\r\n             info=\"\u041e\u0431\u044a\u0435\u043a\u0442 Data , \u0433\u0434\u0435 value \u2014 \u044d\u0442\u043e dict \u0438\u0437 \u043f\u0440\u0438\u043c\u0435\u0440\u0430.\",\r\n             required=True,\r\n         ),\r\n     ]\r\n\r\n\r\n\r\n    outputs = [\r\n        Output(display_name=\"date\", name=\"date\", method=\"extract_ymd\"),\r\n    ]\r\n\r\n\r\n    def extract_ymd(self) -> Data:\r\n        obj = self.input_value.data\r\n        if not isinstance(obj, dict):\r\n            self.log(\"Invalid Data to input\")\r\n            return {}\r\n        try:\r\n            date = obj.get(\"normalized\", {})\r\n            self.log(date)\r\n            if date == {}:\r\n                self.log(\"Invalid Data structure\")\r\n                return {}\r\n            base = date.get(\"base\")\r\n            target = date.get(\"target\")\r\n        except Exception as E:\r\n            self.log(f\"Get error: {E}\")\r\n            return {}\r\n        \r\n        self.status = {\"base\": base, \"target\": target}\r\n        return Data(data={\"base\": base, \"target\": target})\r\n\r\n", "fileTypes": [], "file_path": "", "password": false, "name": "code", "advanced": true, "dynamic": true, "info": "", "load_from_db": false, "title_case": false}}, "description": "\u041f\u0440\u0438\u043d\u0438\u043c\u0430\u0435\u0442 Data \u0441\u043e \u0441\u0442\u0440\u0443\u043a\u0442\u0443\u0440\u043e\u0439 {'normalized': {'base': ..., 'target': ...}} \u0438 \u0432\u043e\u0437\u0432\u0440\u0430\u0449\u0430\u0435\u0442 Data.", "icon": "calendar", "base_classes": ["Data"], "display_name": "Extract base and target codes", "documentation": "https://docs.langflow.org/components-custom-components", "minimized": false, "custom_fields": {}, "output_types": [], "pinned": false, "conditional_paths": [], "frozen": false, "outputs": [{"types": ["Data"], "selected": "Data", "name": "date", "hidden": null, "display_name": "date", "method": "extract_ymd", "value": "__UNDEFINED__", "cache": true, "required_inputs": null, "allows_loop": false, "group_outputs": false, "options": null, "tool_mode": true}], "field_order": ["input_value"], "beta": false, "legacy": false, "edited": true, "metadata": {}, "tool_mode": false, "lf_version": "1.6.3"}, "showNode": true, "type": "extract_codes", "id": "CustomComponent-ttERH"}, "selected": false, "measured": {"width": 320, "height": 181}, "dragging": false}, {"id": "ParserComponent-Cwab2", "type": "genericNode", "position": {"x": 1381.6120777132182, "y": 396.07100282957094}, "data": {"node": {"template": {"_type": "Component", "input_data": {"trace_as_metadata": true, "list": false, "list_add_label": "Add More", "required": true, "placeholder": "", "show": true, "name": "input_data", "value": "", "display_name": "Data or DataFrame", "advanced": false, "input_types": ["DataFrame", "Data"], "dynamic": false, "info": "Accepts either a DataFrame or a Data object.", "title_case": false, "type": "other", "_input_type": "HandleInput"}, "code": {"type": "code", "required": true, "placeholder": "", "list": false, "show": true, "multiline": true, "value": "from langflow.custom.custom_component.component import Component\nfrom langflow.helpers.data import safe_convert\nfrom langflow.inputs.inputs import BoolInput, HandleInput, MessageTextInput, MultilineInput, TabInput\nfrom langflow.schema.data import Data\nfrom langflow.schema.dataframe import DataFrame\nfrom langflow.schema.message import Message\nfrom langflow.template.field.base import Output\n\n\nclass ParserComponent(Component):\n    display_name = \"Parser\"\n    description = \"Extracts text using a template.\"\n    documentation: str = \"https://docs.langflow.org/components-processing#parser\"\n    icon = \"braces\"\n\n    inputs = [\n        HandleInput(\n            name=\"input_data\",\n            display_name=\"Data or DataFrame\",\n            input_types=[\"DataFrame\", \"Data\"],\n            info=\"Accepts either a DataFrame or a Data object.\",\n            required=True,\n        ),\n        TabInput(\n            name=\"mode\",\n            display_name=\"Mode\",\n            options=[\"Parser\", \"Stringify\"],\n            value=\"Parser\",\n            info=\"Convert into raw string instead of using a template.\",\n            real_time_refresh=True,\n        ),\n        MultilineInput(\n            name=\"pattern\",\n            display_name=\"Template\",\n            info=(\n                \"Use variables within curly brackets to extract column values for DataFrames \"\n                \"or key values for Data.\"\n                \"For example: `Name: {Name}, Age: {Age}, Country: {Country}`\"\n            ),\n            value=\"Text: {text}\",  # Example default\n            dynamic=True,\n            show=True,\n            required=True,\n        ),\n        MessageTextInput(\n            name=\"sep\",\n            display_name=\"Separator\",\n            advanced=True,\n            value=\"\\n\",\n            info=\"String used to separate rows/items.\",\n        ),\n    ]\n\n    outputs = [\n        Output(\n            display_name=\"Parsed Text\",\n            name=\"parsed_text\",\n            info=\"Formatted text output.\",\n            method=\"parse_combined_text\",\n        ),\n    ]\n\n    def update_build_config(self, build_config, field_value, field_name=None):\n        \"\"\"Dynamically hide/show `template` and enforce requirement based on `stringify`.\"\"\"\n        if field_name == \"mode\":\n            build_config[\"pattern\"][\"show\"] = self.mode == \"Parser\"\n            build_config[\"pattern\"][\"required\"] = self.mode == \"Parser\"\n            if field_value:\n                clean_data = BoolInput(\n                    name=\"clean_data\",\n                    display_name=\"Clean Data\",\n                    info=(\n                        \"Enable to clean the data by removing empty rows and lines \"\n                        \"in each cell of the DataFrame/ Data object.\"\n                    ),\n                    value=True,\n                    advanced=True,\n                    required=False,\n                )\n                build_config[\"clean_data\"] = clean_data.to_dict()\n            else:\n                build_config.pop(\"clean_data\", None)\n\n        return build_config\n\n    def _clean_args(self):\n        \"\"\"Prepare arguments based on input type.\"\"\"\n        input_data = self.input_data\n\n        match input_data:\n            case list() if all(isinstance(item, Data) for item in input_data):\n                msg = \"List of Data objects is not supported.\"\n                raise ValueError(msg)\n            case DataFrame():\n                return input_data, None\n            case Data():\n                return None, input_data\n            case dict() if \"data\" in input_data:\n                try:\n                    if \"columns\" in input_data:  # Likely a DataFrame\n                        return DataFrame.from_dict(input_data), None\n                    # Likely a Data object\n                    return None, Data(**input_data)\n                except (TypeError, ValueError, KeyError) as e:\n                    msg = f\"Invalid structured input provided: {e!s}\"\n                    raise ValueError(msg) from e\n            case _:\n                msg = f\"Unsupported input type: {type(input_data)}. Expected DataFrame or Data.\"\n                raise ValueError(msg)\n\n    def parse_combined_text(self) -> Message:\n        \"\"\"Parse all rows/items into a single text or convert input to string if `stringify` is enabled.\"\"\"\n        # Early return for stringify option\n        if self.mode == \"Stringify\":\n            return self.convert_to_string()\n\n        df, data = self._clean_args()\n\n        lines = []\n        if df is not None:\n            for _, row in df.iterrows():\n                formatted_text = self.pattern.format(**row.to_dict())\n                lines.append(formatted_text)\n        elif data is not None:\n            formatted_text = self.pattern.format(**data.data)\n            lines.append(formatted_text)\n\n        combined_text = self.sep.join(lines)\n        self.status = combined_text\n        return Message(text=combined_text)\n\n    def convert_to_string(self) -> Message:\n        \"\"\"Convert input data to string with proper error handling.\"\"\"\n        result = \"\"\n        if isinstance(self.input_data, list):\n            result = \"\\n\".join([safe_convert(item, clean_data=self.clean_data or False) for item in self.input_data])\n        else:\n            result = safe_convert(self.input_data or False)\n        self.log(f\"Converted to string with length: {len(result)}\")\n\n        message = Message(text=result)\n        self.status = message\n        return message\n", "fileTypes": [], "file_path": "", "password": false, "name": "code", "advanced": true, "dynamic": true, "info": "", "load_from_db": false, "title_case": false}, "mode": {"tool_mode": false, "trace_as_metadata": true, "options": ["Parser", "Stringify"], "required": false, "placeholder": "", "show": true, "name": "mode", "value": "Parser", "display_name": "Mode", "advanced": false, "dynamic": false, "info": "Convert into raw string instead of using a template.", "real_time_refresh": true, "title_case": false, "type": "tab", "_input_type": "TabInput"}, "pattern": {"tool_mode": false, "trace_as_input": true, "multiline": true, "trace_as_metadata": true, "load_from_db": false, "list": false, "list_add_label": "Add More", "required": true, "placeholder": "", "show": true, "name": "pattern", "value": "{target}", "display_name": "Template", "advanced": false, "input_types": ["Message"], "dynamic": true, "info": "Use variables within curly brackets to extract column values for DataFrames or key values for Data.For example: `Name: {Name}, Age: {Age}, Country: {Country}`", "title_case": false, "copy_field": false, "type": "str", "_input_type": "MultilineInput"}, "sep": {"tool_mode": false, "trace_as_input": true, "trace_as_metadata": true, "load_from_db": false, "list": false, "list_add_label": "Add More", "required": false, "placeholder": "", "show": true, "name": "sep", "value": "\n", "display_name": "Separator", "advanced": true, "input_types": ["Message"], "dynamic": false, "info": "String used to separate rows/items.", "title_case": false, "type": "str", "_input_type": "MessageTextInput"}}, "description": "Extracts text using a template.", "icon": "braces", "base_classes": ["Message"], "display_name": "Parser", "documentation": "https://docs.langflow.org/components-processing#parser", "minimized": false, "custom_fields": {}, "output_types": [], "pinned": false, "conditional_paths": [], "frozen": false, "outputs": [{"types": ["Message"], "selected": "Message", "name": "parsed_text", "display_name": "Parsed Text", "method": "parse_combined_text", "value": "__UNDEFINED__", "cache": true, "allows_loop": false, "group_outputs": false, "tool_mode": true}], "field_order": ["input_data", "mode", "pattern", "sep"], "beta": false, "legacy": false, "edited": false, "metadata": {}, "tool_mode": false, "category": "processing", "key": "ParserComponent", "score": 2.220446049250313e-16, "lf_version": "1.6.3"}, "showNode": true, "type": "ParserComponent", "id": "ParserComponent-Cwab2"}, "selected": false, "measured": {"width": 320, "height": 327}, "dragging": false}, {"id": "ParserComponent-cWwBx", "type": "genericNode", "position": {"x": 1389.3756244892597, "y": 755.6243051265674}, "data": {"node": {"template": {"_type": "Component", "input_data": {"trace_as_metadata": true, "list": false, "list_add_label": "Add More", "required": true, "placeholder": "", "show": true, "name": "input_data", "value": "", "display_name": "Data or DataFrame", "advanced": false, "input_types": ["DataFrame", "Data"], "dynamic": false, "info": "Accepts either a DataFrame or a Data object.", "title_case": false, "type": "other", "_input_type": "HandleInput"}, "code": {"type": "code", "required": true, "placeholder": "", "list": false, "show": true, "multiline": true, "value": "from langflow.custom.custom_component.component import Component\nfrom langflow.helpers.data import safe_convert\nfrom langflow.inputs.inputs import BoolInput, HandleInput, MessageTextInput, MultilineInput, TabInput\nfrom langflow.schema.data import Data\nfrom langflow.schema.dataframe import DataFrame\nfrom langflow.schema.message import Message\nfrom langflow.template.field.base import Output\n\n\nclass ParserComponent(Component):\n    display_name = \"Parser\"\n    description = \"Extracts text using a template.\"\n    documentation: str = \"https://docs.langflow.org/components-processing#parser\"\n    icon = \"braces\"\n\n    inputs = [\n        HandleInput(\n            name=\"input_data\",\n            display_name=\"Data or DataFrame\",\n            input_types=[\"DataFrame\", \"Data\"],\n            info=\"Accepts either a DataFrame or a Data object.\",\n            required=True,\n        ),\n        TabInput(\n            name=\"mode\",\n            display_name=\"Mode\",\n            options=[\"Parser\", \"Stringify\"],\n            value=\"Parser\",\n            info=\"Convert into raw string instead of using a template.\",\n            real_time_refresh=True,\n        ),\n        MultilineInput(\n            name=\"pattern\",\n            display_name=\"Template\",\n            info=(\n                \"Use variables within curly brackets to extract column values for DataFrames \"\n                \"or key values for Data.\"\n                \"For example: `Name: {Name}, Age: {Age}, Country: {Country}`\"\n            ),\n            value=\"Text: {text}\",  # Example default\n            dynamic=True,\n            show=True,\n            required=True,\n        ),\n        MessageTextInput(\n            name=\"sep\",\n            display_name=\"Separator\",\n            advanced=True,\n            value=\"\\n\",\n            info=\"String used to separate rows/items.\",\n        ),\n    ]\n\n    outputs = [\n        Output(\n            display_name=\"Parsed Text\",\n            name=\"parsed_text\",\n            info=\"Formatted text output.\",\n            method=\"parse_combined_text\",\n        ),\n    ]\n\n    def update_build_config(self, build_config, field_value, field_name=None):\n        \"\"\"Dynamically hide/show `template` and enforce requirement based on `stringify`.\"\"\"\n        if field_name == \"mode\":\n            build_config[\"pattern\"][\"show\"] = self.mode == \"Parser\"\n            build_config[\"pattern\"][\"required\"] = self.mode == \"Parser\"\n            if field_value:\n                clean_data = BoolInput(\n                    name=\"clean_data\",\n                    display_name=\"Clean Data\",\n                    info=(\n                        \"Enable to clean the data by removing empty rows and lines \"\n                        \"in each cell of the DataFrame/ Data object.\"\n                    ),\n                    value=True,\n                    advanced=True,\n                    required=False,\n                )\n                build_config[\"clean_data\"] = clean_data.to_dict()\n            else:\n                build_config.pop(\"clean_data\", None)\n\n        return build_config\n\n    def _clean_args(self):\n        \"\"\"Prepare arguments based on input type.\"\"\"\n        input_data = self.input_data\n\n        match input_data:\n            case list() if all(isinstance(item, Data) for item in input_data):\n                msg = \"List of Data objects is not supported.\"\n                raise ValueError(msg)\n            case DataFrame():\n                return input_data, None\n            case Data():\n                return None, input_data\n            case dict() if \"data\" in input_data:\n                try:\n                    if \"columns\" in input_data:  # Likely a DataFrame\n                        return DataFrame.from_dict(input_data), None\n                    # Likely a Data object\n                    return None, Data(**input_data)\n                except (TypeError, ValueError, KeyError) as e:\n                    msg = f\"Invalid structured input provided: {e!s}\"\n                    raise ValueError(msg) from e\n            case _:\n                msg = f\"Unsupported input type: {type(input_data)}. Expected DataFrame or Data.\"\n                raise ValueError(msg)\n\n    def parse_combined_text(self) -> Message:\n        \"\"\"Parse all rows/items into a single text or convert input to string if `stringify` is enabled.\"\"\"\n        # Early return for stringify option\n        if self.mode == \"Stringify\":\n            return self.convert_to_string()\n\n        df, data = self._clean_args()\n\n        lines = []\n        if df is not None:\n            for _, row in df.iterrows():\n                formatted_text = self.pattern.format(**row.to_dict())\n                lines.append(formatted_text)\n        elif data is not None:\n            formatted_text = self.pattern.format(**data.data)\n            lines.append(formatted_text)\n\n        combined_text = self.sep.join(lines)\n        self.status = combined_text\n        return Message(text=combined_text)\n\n    def convert_to_string(self) -> Message:\n        \"\"\"Convert input data to string with proper error handling.\"\"\"\n        result = \"\"\n        if isinstance(self.input_data, list):\n            result = \"\\n\".join([safe_convert(item, clean_data=self.clean_data or False) for item in self.input_data])\n        else:\n            result = safe_convert(self.input_data or False)\n        self.log(f\"Converted to string with length: {len(result)}\")\n\n        message = Message(text=result)\n        self.status = message\n        return message\n", "fileTypes": [], "file_path": "", "password": false, "name": "code", "advanced": true, "dynamic": true, "info": "", "load_from_db": false, "title_case": false}, "mode": {"tool_mode": false, "trace_as_metadata": true, "options": ["Parser", "Stringify"], "required": false, "placeholder": "", "show": true, "name": "mode", "value": "Parser", "display_name": "Mode", "advanced": false, "dynamic": false, "info": "Convert into raw string instead of using a template.", "real_time_refresh": true, "title_case": false, "type": "tab", "_input_type": "TabInput"}, "pattern": {"tool_mode": false, "trace_as_input": true, "multiline": true, "trace_as_metadata": true, "load_from_db": false, "list": false, "list_add_label": "Add More", "required": true, "placeholder": "", "show": true, "name": "pattern", "value": "{base}", "display_name": "Template", "advanced": false, "input_types": ["Message"], "dynamic": true, "info": "Use variables within curly brackets to extract column values for DataFrames or key values for Data.For example: `Name: {Name}, Age: {Age}, Country: {Country}`", "title_case": false, "copy_field": false, "type": "str", "_input_type": "MultilineInput"}, "sep": {"tool_mode": false, "trace_as_input": true, "trace_as_metadata": true, "load_from_db": false, "list": false, "list_add_label": "Add More", "required": false, "placeholder": "", "show": true, "name": "sep", "value": "\n", "display_name": "Separator", "advanced": true, "input_types": ["Message"], "dynamic": false, "info": "String used to separate rows/items.", "title_case": false, "type": "str", "_input_type": "MessageTextInput"}}, "description": "Extracts text using a template.", "icon": "braces", "base_classes": ["Message"], "display_name": "Parser", "documentation": "https://docs.langflow.org/components-processing#parser", "minimized": false, "custom_fields": {}, "output_types": [], "pinned": false, "conditional_paths": [], "frozen": false, "outputs": [{"types": ["Message"], "selected": "Message", "name": "parsed_text", "display_name": "Parsed Text", "method": "parse_combined_text", "value": "__UNDEFINED__", "cache": true, "allows_loop": false, "group_outputs": false, "tool_mode": true}], "field_order": ["input_data", "mode", "pattern", "sep"], "beta": false, "legacy": false, "edited": false, "metadata": {}, "tool_mode": false, "category": "processing", "key": "ParserComponent", "score": 2.220446049250313e-16, "lf_version": "1.6.3"}, "showNode": true, "type": "ParserComponent", "id": "ParserComponent-cWwBx"}, "selected": false, "measured": {"width": 320, "height": 327}, "dragging": false}, {"id": "TextOutput-g3ixe", "type": "genericNode", "position": {"x": -748.867690363578, "y": 2271.1367865592583}, "data": {"node": {"template": {"_type": "Component", "input_value": {"tool_mode": false, "trace_as_metadata": true, "list": false, "list_add_label": "Add More", "trace_as_input": true, "required": false, "placeholder": "", "show": true, "name": "input_value", "value": "", "display_name": "Inputs", "advanced": false, "input_types": ["Data"], "dynamic": false, "info": "Text to be passed as output.", "title_case": false, "type": "other", "_input_type": "DataInput"}, "code": {"type": "code", "required": true, "placeholder": "", "list": false, "show": true, "multiline": true, "value": "from langflow.base.io.text import TextComponent\nfrom langflow.io import MultilineInput, Output\nfrom langflow.schema.message import Message\n\n\nclass TextOutputComponent(TextComponent):\n    display_name = \"Input logger\"\n    description = \"INput logger.\"\n    documentation: str = \"https://docs.langflow.org/components-io#text-output\"\n    icon = \"type\"\n    name = \"TextOutput\"\n\n    inputs = [\n        DataInput(\n            name=\"input_value\",\n            display_name=\"Inputs\",\n            info=\"Text to be passed as output.\",\n        ),\n    ]\n    outputs = [\n        Output(display_name=\"Output Text\", name=\"text\", method=\"text_response\"),\n    ]\n\n    def text_response(self) -> Message:\n        data = self.input_value.data\n        self.status = data\n        self.log(str(data))\n        return {}\n", "fileTypes": [], "file_path": "", "password": false, "name": "code", "advanced": true, "dynamic": true, "info": "", "load_from_db": false, "title_case": false}}, "description": "INput logger.", "icon": "type", "base_classes": ["Message"], "display_name": "Input logger", "documentation": "https://docs.langflow.org/components-io#text-output", "minimized": false, "custom_fields": {}, "output_types": [], "pinned": false, "conditional_paths": [], "frozen": false, "outputs": [{"types": ["Message"], "selected": "Message", "name": "text", "hidden": null, "display_name": "Output Text", "method": "text_response", "value": "__UNDEFINED__", "cache": true, "required_inputs": null, "allows_loop": false, "group_outputs": false, "options": null, "tool_mode": true}], "field_order": ["input_value"], "beta": false, "legacy": false, "edited": true, "metadata": {}, "tool_mode": false, "lf_version": "1.6.3"}, "showNode": true, "type": "TextOutput", "id": "TextOutput-g3ixe"}, "selected": false, "measured": {"width": 320, "height": 165}}, {"id": "GetEnvVar-uYtCL", "type": "genericNode", "position": {"x": -1980.9046552740558, "y": 1827.6924644848089}, "data": {"id": "GetEnvVar-uYtCL", "node": {"base_classes": ["Message"], "beta": false, "category": "datastax", "conditional_paths": [], "custom_fields": {}, "description": "Gets the value of an environment variable from the system.", "display_name": "Get Environment Variable", "documentation": "", "edited": false, "field_order": ["env_var_name"], "frozen": false, "icon": "AstraDB", "key": "GetEnvVar", "legacy": false, "lf_version": "1.6.3", "metadata": {}, "minimized": false, "output_types": [], "outputs": [{"allows_loop": false, "cache": true, "display_name": "Environment Variable Value", "group_outputs": false, "method": "process_inputs", "name": "env_var_value", "selected": "Message", "tool_mode": true, "types": ["Message"], "value": "__UNDEFINED__"}], "pinned": false, "score": 0.15609486447437038, "template": {"_type": "Component", "code": {"advanced": true, "dynamic": true, "fileTypes": [], "file_path": "", "info": "", "list": false, "load_from_db": false, "multiline": true, "name": "code", "password": false, "placeholder": "", "required": true, "show": true, "title_case": false, "type": "code", "value": "import os\n\nfrom langflow.custom.custom_component.component import Component\nfrom langflow.inputs.inputs import StrInput\nfrom langflow.schema.message import Message\nfrom langflow.template.field.base import Output\n\n\nclass GetEnvVar(Component):\n    display_name = \"Get Environment Variable\"\n    description = \"Gets the value of an environment variable from the system.\"\n    icon = \"AstraDB\"\n\n    inputs = [\n        StrInput(\n            name=\"env_var_name\",\n            display_name=\"Environment Variable Name\",\n            info=\"Name of the environment variable to get\",\n        )\n    ]\n\n    outputs = [\n        Output(display_name=\"Environment Variable Value\", name=\"env_var_value\", method=\"process_inputs\"),\n    ]\n\n    def process_inputs(self) -> Message:\n        if self.env_var_name not in os.environ:\n            msg = f\"Environment variable {self.env_var_name} not set\"\n            raise ValueError(msg)\n        return Message(text=os.environ[self.env_var_name])\n"}, "env_var_name": {"_input_type": "StrInput", "advanced": false, "display_name": "Environment Variable Name", "dynamic": false, "info": "Name of the environment variable to get", "list": false, "list_add_label": "Add More", "load_from_db": false, "name": "env_var_name", "placeholder": "", "required": false, "show": true, "title_case": false, "tool_mode": false, "trace_as_metadata": true, "type": "str", "value": "GIGA_API_KEY"}}, "tool_mode": false}, "showNode": true, "type": "GetEnvVar"}, "selected": false, "measured": {"width": 320, "height": 219}, "dragging": false}, {"id": "ChatInput-a3rZn", "type": "genericNode", "position": {"x": -1900.4246641838497, "y": 1605.917642298779}, "data": {"node": {"template": {"_type": "Component", "files": {"trace_as_metadata": true, "file_path": "", "fileTypes": ["csv", "json", "pdf", "txt", "md", "mdx", "yaml", "yml", "xml", "html", "htm", "docx", "py", "sh", "sql", "js", "ts", "tsx", "jpg", "jpeg", "png", "bmp", "image"], "temp_file": true, "list": true, "list_add_label": "Add More", "required": false, "placeholder": "", "show": true, "name": "files", "value": "", "display_name": "Files", "advanced": true, "dynamic": false, "info": "Files to be sent with the message.", "title_case": false, "type": "file", "_input_type": "FileInput"}, "code": {"type": "code", "required": true, "placeholder": "", "list": false, "show": true, "multiline": true, "value": "from langflow.base.data.utils import IMG_FILE_TYPES, TEXT_FILE_TYPES\nfrom langflow.base.io.chat import ChatComponent\nfrom langflow.inputs.inputs import BoolInput\nfrom langflow.io import (\n    DropdownInput,\n    FileInput,\n    MessageTextInput,\n    MultilineInput,\n    Output,\n)\nfrom langflow.schema.message import Message\nfrom langflow.utils.constants import (\n    MESSAGE_SENDER_AI,\n    MESSAGE_SENDER_NAME_USER,\n    MESSAGE_SENDER_USER,\n)\n\n\nclass ChatInput(ChatComponent):\n    display_name = \"Chat Input\"\n    description = \"\u041d\u0435\u043e\u0431\u0445\u043e\u0434\u0438\u043c\u043e \u043f\u0435\u0440\u0435\u0434\u0430\u0442\u044c \u0434\u0435\u043d\u044c, \u043c\u0435\u0441\u044f\u0446, \u0433\u043e\u0434, \u0431\u0430\u0437\u043e\u0432\u0443\u044e \u0438 \u0446\u0435\u043b\u0435\u0432\u0443\u044e \u0432\u0430\u043b\u044e\u0442\u0443. \u041c\u043e\u0436\u043d\u043e \u0435\u0449\u0451 \u043f\u0435\u0440\u0435\u0434\u0430\u0442\u044c \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u0431\u0430\u0437\u043e\u0432\u043e\u0439 \u0432\u0430\u043b\u044e\u0442\u044b\"\n    documentation: str = \"https://docs.langflow.org/components-io#chat-input\"\n    icon = \"MessagesSquare\"\n    name = \"ChatInput\"\n    minimized = True\n\n    inputs = [\n        MultilineInput(\n            name=\"input_value\",\n            display_name=\"Input Text\",\n            value=\"\",\n            info=\"Message to be passed as input.\",\n            input_types=[],\n        ),\n        BoolInput(\n            name=\"should_store_message\",\n            display_name=\"Store Messages\",\n            info=\"Store the message in the history.\",\n            value=True,\n            advanced=True,\n        ),\n        DropdownInput(\n            name=\"sender\",\n            display_name=\"Sender Type\",\n            options=[MESSAGE_SENDER_AI, MESSAGE_SENDER_USER],\n            value=MESSAGE_SENDER_USER,\n            info=\"Type of sender.\",\n            advanced=True,\n        ),\n        MessageTextInput(\n            name=\"sender_name\",\n            display_name=\"Sender Name\",\n            info=\"Name of the sender.\",\n            value=MESSAGE_SENDER_NAME_USER,\n            advanced=True,\n        ),\n        MessageTextInput(\n            name=\"session_id\",\n            display_name=\"Session ID\",\n            info=\"The session ID of the chat. If empty, the current session ID parameter will be used.\",\n            advanced=True,\n        ),\n        FileInput(\n            name=\"files\",\n            display_name=\"Files\",\n            file_types=TEXT_FILE_TYPES + IMG_FILE_TYPES,\n            info=\"Files to be sent with the message.\",\n            advanced=True,\n            is_list=True,\n            temp_file=True,\n        ),\n    ]\n    outputs = [\n        Output(display_name=\"Chat Message\", name=\"message\", method=\"message_response\"),\n    ]\n\n    async def message_response(self) -> Message:\n        # Ensure files is a list and filter out empty/None values\n        files = self.files if self.files else []\n        if files and not isinstance(files, list):\n            files = [files]\n        files = [f for f in files if f is not None and f != \"\"]\n\n        message = await Message.create(\n            text=self.input_value,\n            sender=self.sender,\n            sender_name=self.sender_name,\n            session_id=self.session_id,\n            files=files,\n        )\n        if self.session_id and isinstance(message, Message) and self.should_store_message:\n            stored_message = await self.send_message(\n                message,\n            )\n            self.message.value = stored_message\n            message = stored_message\n\n        self.status = message\n        return message\n", "fileTypes": [], "file_path": "", "password": false, "name": "code", "advanced": true, "dynamic": true, "info": "", "load_from_db": false, "title_case": false}, "input_value": {"tool_mode": false, "trace_as_input": true, "multiline": true, "trace_as_metadata": true, "load_from_db": false, "list": false, "list_add_label": "Add More", "required": false, "placeholder": "", "show": true, "name": "input_value", "value": "", "display_name": "Input Text", "advanced": false, "input_types": [], "dynamic": false, "info": "Message to be passed as input.", "title_case": false, "copy_field": false, "type": "str", "_input_type": "MultilineInput"}, "sender": {"tool_mode": false, "trace_as_metadata": true, "options": ["Machine", "User"], "options_metadata": [], "combobox": false, "dialog_inputs": {}, "toggle": false, "required": false, "placeholder": "", "show": true, "name": "sender", "value": "User", "display_name": "Sender Type", "advanced": true, "dynamic": false, "info": "Type of sender.", "title_case": false, "external_options": {}, "type": "str", "_input_type": "DropdownInput"}, "sender_name": {"tool_mode": false, "trace_as_input": true, "trace_as_metadata": true, "load_from_db": false, "list": false, "list_add_label": "Add More", "required": false, "placeholder": "", "show": true, "name": "sender_name", "value": "User", "display_name": "Sender Name", "advanced": true, "input_types": ["Message"], "dynamic": false, "info": "Name of the sender.", "title_case": false, "type": "str", "_input_type": "MessageTextInput"}, "session_id": {"tool_mode": false, "trace_as_input": true, "trace_as_metadata": true, "load_from_db": false, "list": false, "list_add_label": "Add More", "required": false, "placeholder": "", "show": true, "name": "session_id", "value": "", "display_name": "Session ID", "advanced": true, "input_types": ["Message"], "dynamic": false, "info": "The session ID of the chat. If empty, the current session ID parameter will be used.", "title_case": false, "type": "str", "_input_type": "MessageTextInput"}, "should_store_message": {"tool_mode": false, "trace_as_metadata": true, "list": false, "list_add_label": "Add More", "required": false, "placeholder": "", "show": true, "name": "should_store_message", "value": true, "display_name": "Store Messages", "advanced": true, "dynamic": false, "info": "Store the message in the history.", "title_case": false, "type": "bool", "_input_type": "BoolInput"}}, "description": "\u041d\u0435\u043e\u0431\u0445\u043e\u0434\u0438\u043c\u043e \u043f\u0435\u0440\u0435\u0434\u0430\u0442\u044c \u0434\u0435\u043d\u044c, \u043c\u0435\u0441\u044f\u0446, \u0433\u043e\u0434, \u0431\u0430\u0437\u043e\u0432\u0443\u044e \u0438 \u0446\u0435\u043b\u0435\u0432\u0443\u044e \u0432\u0430\u043b\u044e\u0442\u0443. \u041c\u043e\u0436\u043d\u043e \u0435\u0449\u0451 \u043f\u0435\u0440\u0435\u0434\u0430\u0442\u044c \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u0431\u0430\u0437\u043e\u0432\u043e\u0439 \u0432\u0430\u043b\u044e\u0442\u044b", "icon": "MessagesSquare", "base_classes": ["Message"], "display_name": "Chat Input", "documentation": "https://docs.langflow.org/components-io#chat-input", "minimized": true, "custom_fields": {}, "output_types": [], "pinned": false, "conditional_paths": [], "frozen": false, "outputs": [{"types": ["Message"], "selected": "Message", "name": "message", "hidden": null, "display_name": "Chat Message", "method": "message_response", "value": "__UNDEFINED__", "cache": true, "required_inputs": null, "allows_loop": false, "group_outputs": false, "options": null, "tool_mode": true}], "field_order": ["input_value", "should_store_message", "sender", "sender_name", "session_id", "files"], "beta": false, "legacy": false, "edited": true, "metadata": {}, "tool_mode": false}, "showNode": false, "type": "ChatInput", "id": "ChatInput-a3rZn"}, "selected": false, "measured": {"width": 192, "height": 48}}, {"id": "GChatStructured-p3gif", "type": "genericNode", "position": {"x": -1258.323041674804, "y": 1481.61683574835}, "data": {"id": "GChatStructured-p3gif", "node": {"base_classes": ["Data"], "beta": false, "conditional_paths": [], "custom_fields": {}, "description": "Structured output via Function Calling. If schema isn't valid, answer will be: {'answer': 'str'}", "display_name": "GigaChat Structured Output", "documentation": "http://docs.langflow.org/components/custom", "edited": true, "field_order": ["input_message", "giga_api", "model_name", "scope", "output_schema", "function_name", "function_description", "system_prompt", "temperature"], "frozen": false, "icon": "custom_components", "legacy": false, "lf_version": "1.6.3", "metadata": {}, "minimized": false, "output_types": [], "outputs": [{"allows_loop": false, "cache": true, "display_name": "Structured Output", "group_outputs": false, "hidden": null, "method": "build_output", "name": "output", "options": null, "required_inputs": null, "selected": "Data", "tool_mode": true, "types": ["Data"], "value": "__UNDEFINED__"}], "pinned": false, "template": {"_type": "Component", "code": {"advanced": true, "dynamic": true, "fileTypes": [], "file_path": "", "info": "", "list": false, "load_from_db": false, "multiline": true, "name": "code", "password": false, "placeholder": "", "required": true, "show": true, "title_case": false, "type": "code", "value": "from typing import Any, Dict\r\nfrom langflow.custom import Component\r\nfrom langflow.io import MessageTextInput, Output, DropdownInput, StrInput, CodeInput\r\nfrom langflow.schema import Data\r\nimport json, requests, uuid\r\n\r\nJSON_TYPE_MAP = {\r\n    \"str\": \"string\",\r\n    \"string\": \"string\",\r\n    \"int\": \"integer\",\r\n    \"integer\": \"integer\",\r\n    \"float\": \"number\",\r\n    \"number\": \"number\",\r\n    \"bool\": \"boolean\",\r\n    \"boolean\": \"boolean\",\r\n    \"list\": \"array\",\r\n    \"array\": \"array\",\r\n    \"dict\": \"object\",\r\n    \"object\": \"object\",\r\n}\r\n\r\nclass GChatStructured(Component):\r\n    display_name = \"GigaChat Structured Output\"\r\n    description = \"Structured output via Function Calling. If schema isn't valid, answer will be: {'answer': 'str'}\"\r\n    documentation: str = \"http://docs.langflow.org/components/custom\"\r\n    icon = \"custom_components\"\r\n\r\n    model_list = [\"GigaChat-2\", \"GigaChat-2-Pro\", \"GigaChat-2-Max\"]\r\n    scope_list = [\"GIGACHAT_API_PERS\", \"GIGACHAT_API_CORP\", \"GIGACHAT_API_B2B\"]\r\n\r\n    inputs = [\r\n        MessageTextInput(name=\"input_message\", display_name=\"Input Message\"),\r\n        StrInput(name=\"giga_api\", display_name=\"GigaChat API Key (Base64 credentials)\", input_types=[\"str\",\"Message\"]),\r\n        DropdownInput(name=\"model_name\", display_name=\"Model\", options=model_list, value=\"GigaChat-2\"),\r\n        DropdownInput(name=\"scope\", display_name=\"Scope\", options=scope_list, value=\"GIGACHAT_API_PERS\"),\r\n        CodeInput(\r\n            name=\"output_schema\",\r\n            display_name=\"Output Schema (JSON or simplified)\",\r\n            info='Either full JSON Schema properties map, or simplified types like {\"answer\":\"str\",\"confidence\":\"float\",\"skills\":\"array\"}',\r\n            value='{\"answer\":\"str\",\"confidence\":\"float\",\"skills\":{\"type\":\"array\",\"items\":{\"type\":\"string\"}}}'\r\n        ),\r\n        MessageTextInput(name=\"function_name\", display_name=\"Function Name\", value=\"extract_data\"),\r\n        MessageTextInput(name=\"function_description\", display_name=\"Function Description\", value=\"Extract structured data from the input\"),\r\n        MultilineInput(name=\"system_prompt\", display_name=\"System Prompt\", value=\"\u0422\u044b \u2014 \u0443\u043c\u043d\u044b\u0439 \u0430\u0441\u0441\u0438\u0441\u0442\u0435\u043d\u0442. \u0418\u0437\u0432\u043b\u0435\u043a\u0430\u0439 \u0434\u0430\u043d\u043d\u044b\u0435 \u0432 \u0437\u0430\u0434\u0430\u043d\u043d\u043e\u0439 \u0441\u0445\u0435\u043c\u0435.\"),\r\n        MessageTextInput(name=\"temperature\", display_name=\"Temperature\", value=\"0.1\"),\r\n    ]\r\n\r\n    outputs = [Output(display_name=\"Structured Output\", name=\"output\", method=\"build_output\", type=\"Data\")]\r\n\r\n    def _get_text(self, v: Any) -> str:\r\n        try:\r\n            if hasattr(v, \"text\"):\r\n                return v.text or \"\"\r\n        except Exception:\r\n            pass\r\n        if isinstance(v, dict) and \"text\" in v:\r\n            return str(v.get(\"text\") or \"\")\r\n        return str(v or \"\")\r\n\r\n    def _get_access_token(self, credentials: str, scope: str) -> str:\r\n        url = \"https://ngw.devices.sberbank.ru:9443/api/v2/oauth\"\r\n        headers = {\r\n            \"Content-Type\": \"application/x-www-form-urlencoded\",\r\n            \"Accept\": \"application/json\",\r\n            \"RqUID\": str(uuid.uuid4()),\r\n            \"Authorization\": f\"Basic {credentials}\",\r\n        }\r\n        resp = requests.post(url, headers=headers, data={\"scope\": scope}, timeout=30, verify=False)\r\n        resp.raise_for_status()\r\n        return resp.json()[\"access_token\"]\r\n\r\n    def _normalize_properties(self, schema_like: Dict) -> Dict:\r\n        props = {}\r\n        required = []\r\n        for name, spec in schema_like.items():\r\n            if isinstance(spec, dict) and \"type\" in spec:\r\n                t = JSON_TYPE_MAP.get(str(spec[\"type\"]).lower()) or \"string\"\r\n                out = dict(spec)\r\n                out[\"type\"] = t\r\n                if t == \"array\" and \"items\" not in out:\r\n                    out[\"items\"] = {\"type\": \"string\"}\r\n                props[name] = out\r\n            else:\r\n                t = JSON_TYPE_MAP.get(str(spec).lower(), \"string\")\r\n                props[name] = {\"type\": t}\r\n                if t == \"array\":\r\n                    props[name][\"items\"] = {\"type\": \"string\"}\r\n            # \u0434\u0435\u043b\u0430\u0435\u043c \u043a\u043b\u044e\u0447 \u043e\u0431\u044f\u0437\u0430\u0442\u0435\u043b\u044c\u043d\u044b\u043c\r\n            required.append(name)\r\n        return {\"type\": \"object\", \"properties\": props, \"required\": required}\r\n\r\n\r\n    def _build_function(self, name: str, description: str, schema_input: Any) -> Dict:\r\n        if isinstance(schema_input, str):\r\n            try:\r\n                schema_like = json.loads(schema_input)\r\n            except json.JSONDecodeError:\r\n                # \u0442\u0440\u0430\u043a\u0442\u0443\u0435\u043c \u043a\u0430\u043a \u043e\u0434\u0438\u043d \u0441\u0442\u0440\u043e\u043a\u043e\u0432\u044b\u0439 \u043e\u0442\u0432\u0435\u0442\r\n                schema_like = {\"answer\": \"str\"}\r\n        elif isinstance(schema_input, dict):\r\n            schema_like = schema_input\r\n        else:\r\n            schema_like = {\"answer\": \"str\"}\r\n        parameters = self._normalize_properties(schema_like)\r\n        return {\"name\": name, \"description\": description, \"parameters\": parameters}\r\n\r\n    def _validate_function(self, access_token: str, function_obj: Dict) -> Dict:\r\n        url = \"https://gigachat.devices.sberbank.ru/api/v1/functions/validate\"\r\n        headers = {\"Content-Type\": \"application/json\", \"Authorization\": f\"Bearer {access_token}\", \"Accept\": \"application/json\"}\r\n        resp = requests.post(url, headers=headers, json=function_obj, timeout=30, verify=False)\r\n        # \u043d\u0435 \u043f\u0430\u0434\u0430\u0435\u043c \u043f\u043e \u0441\u0442\u0430\u0442\u0443\u0441\u0443 \u2014 \u0432\u043e\u0437\u0432\u0440\u0430\u0449\u0430\u0435\u043c \u0442\u0435\u043a\u0441\u0442 \u0434\u0438\u0430\u0433\u043d\u043e\u0441\u0442\u0438\u043a\u0438\r\n        try:\r\n            data = resp.json()\r\n        except Exception:\r\n            data = {\"status_code\": resp.status_code, \"text\": resp.text[:500]}\r\n        return data\r\n\r\n    def build_output(self) -> Data:\r\n        temperature = float(self.temperature)\r\n        access_token = self._get_access_token(self._get_text(self.giga_api), self.scope)\r\n\r\n        fn = self._build_function(self.function_name, self.function_description, self.output_schema)\r\n        validation = self._validate_function(access_token, fn)  # \u043f\u043e\u043b\u0435\u0437\u043d\u043e \u0434\u043b\u044f \u043e\u0442\u043b\u0430\u0434\u043a\u0438\r\n        # \u043c\u043e\u0436\u043d\u043e \u043f\u0440\u043e\u0432\u0435\u0440\u0438\u0442\u044c warnings \u0438 \u043f\u043e\u0434\u0441\u043a\u0430\u0437\u0430\u0442\u044c \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044e\r\n\r\n        url = \"https://gigachat.devices.sberbank.ru/api/v1/chat/completions\"\r\n        headers = {\"Content-Type\": \"application/json\", \"Authorization\": f\"Bearer {access_token}\", \"Accept\": \"application/json\"}\r\n        payload = {\r\n            \"model\": self.model_name,\r\n            \"messages\": [\r\n                {\"role\": \"system\", \"content\": self.system_prompt},\r\n                {\"role\": \"user\", \"content\": self.input_message},\r\n            ],\r\n            \"temperature\": temperature,\r\n            \"function_call\": {\"name\": self.function_name},\r\n            \"functions\": [fn],\r\n            # \"stream\": False,  # \u043f\u0440\u0438 \u043d\u0435\u043e\u0431\u0445\u043e\u0434\u0438\u043c\u043e\u0441\u0442\u0438\r\n        }\r\n\r\n        try:\r\n            resp = requests.post(url, headers=headers, json=payload, timeout=60, verify=False)\r\n            # \u0432\u043c\u0435\u0441\u0442\u043e raise_for_status \u0447\u0438\u0442\u0430\u0435\u043c \u0442\u0435\u043b\u043e \u043e\u0448\u0438\u0431\u043a\u0438, \u0447\u0442\u043e\u0431\u044b \u0443\u0432\u0438\u0434\u0435\u0442\u044c \u043f\u0440\u0438\u0447\u0438\u043d\u0443 422\r\n            try:\r\n                body = resp.json()\r\n            except Exception:\r\n                body = {\"status_code\": resp.status_code, \"text\": resp.text[:1000]}\r\n\r\n            if resp.status_code != 200:\r\n                return Data(data={\"error\": body, \"validation\": validation}, text=json.dumps({\"error\": body, \"validation\": validation}, ensure_ascii=False, indent=2))\r\n\r\n            choice0 = (body.get(\"choices\") or [{}])[0]\r\n            msg = choice0.get(\"message\", {})\r\n            fn_call = msg.get(\"function_call\", {})\r\n            args = fn_call.get(\"arguments\", {})\r\n            return Data(data=args)\r\n\r\n        except Exception as e:\r\n            return Data(data={\"error\": str(e)}, text=f\"Error: {str(e)}\")\r\n"}, "function_description": {"_input_type": "MessageTextInput", "advanced": false, "display_name": "Function Description", "dynamic": false, "info": "", "input_types": ["Message"], "list": false, "list_add_label": "Add More", "load_from_db": false, "name": "function_description", "placeholder": "", "required": false, "show": true, "title_case": false, "tool_mode": false, "trace_as_input": true, "trace_as_metadata": true, "type": "str", "value": "\u043f\u0430\u0440\u0441\u0438\u043d\u0433 \u0430\u0440\u0433\u0443\u043c\u0435\u043d\u0442\u043e\u0432"}, "function_name": {"_input_type": "MessageTextInput", "advanced": false, "display_name": "Function Name", "dynamic": false, "info": "", "input_types": ["Message"], "list": false, "list_add_label": "Add More", "load_from_db": false, "name": "function_name", "placeholder": "", "required": false, "show": true, "title_case": false, "tool_mode": false, "trace_as_input": true, "trace_as_metadata": true, "type": "str", "value": "structured"}, "giga_api": {"_input_type": "StrInput", "advanced": false, "display_name": "GigaChat API Key (Base64 credentials)", "dynamic": false, "info": "", "input_types": ["str", "Message"], "list": false, "list_add_label": "Add More", "load_from_db": false, "name": "giga_api", "placeholder": "", "required": false, "show": true, "title_case": false, "tool_mode": false, "trace_as_metadata": true, "type": "str", "value": ""}, "input_message": {"_input_type": "MessageTextInput", "advanced": false, "display_name": "Input Message", "dynamic": false, "info": "", "input_types": ["Message"], "list": false, "list_add_label": "Add More", "load_from_db": false, "name": "input_message", "placeholder": "", "required": false, "show": true, "title_case": false, "tool_mode": false, "trace_as_input": true, "trace_as_metadata": true, "type": "str", "value": ""}, "model_name": {"_input_type": "DropdownInput", "advanced": false, "combobox": false, "dialog_inputs": {}, "display_name": "Model", "dynamic": false, "external_options": {}, "info": "", "name": "model_name", "options": ["GigaChat-2", "GigaChat-2-Pro", "GigaChat-2-Max"], "options_metadata": [], "placeholder": "", "required": false, "show": true, "title_case": false, "toggle": false, "tool_mode": false, "trace_as_metadata": true, "type": "str", "value": "GigaChat-2"}, "output_schema": {"_input_type": "CodeInput", "advanced": false, "display_name": "Output Schema (JSON or simplified)", "dynamic": false, "info": "Either full JSON Schema properties map, or simplified types like {\"answer\":\"str\",\"confidence\":\"float\",\"skills\":\"array\"}", "list": false, "list_add_label": "Add More", "load_from_db": false, "name": "output_schema", "placeholder": "", "required": false, "show": true, "title_case": false, "tool_mode": false, "trace_as_input": true, "type": "code", "value": "{'year': \"int\", \"month\": \"int\", \"day\": \"int\", \"base\": \"str\", \"target\": \"str\", \"amount\": \"float\"}"}, "scope": {"_input_type": "DropdownInput", "advanced": false, "combobox": false, "dialog_inputs": {}, "display_name": "Scope", "dynamic": false, "external_options": {}, "info": "", "name": "scope", "options": ["GIGACHAT_API_PERS", "GIGACHAT_API_CORP", "GIGACHAT_API_B2B"], "options_metadata": [], "placeholder": "", "required": false, "show": true, "title_case": false, "toggle": false, "tool_mode": false, "trace_as_metadata": true, "type": "str", "value": "GIGACHAT_API_PERS"}, "system_prompt": {"_input_type": "MultilineInput", "advanced": false, "copy_field": false, "display_name": "System Prompt", "dynamic": false, "info": "", "input_types": ["Message"], "list": false, "list_add_label": "Add More", "load_from_db": false, "multiline": true, "name": "system_prompt", "placeholder": "", "required": false, "show": true, "title_case": false, "tool_mode": false, "trace_as_input": true, "trace_as_metadata": true, "type": "str", "value": "\u0422\u0435\u0431\u0435 \u043d\u0443\u0436\u043d\u043e \u0440\u0430\u0441\u043f\u0430\u0440\u0441\u0438\u0442\u044c \u0432\u0445\u043e\u0434 \u0438 \u0432\u0441\u0442\u0430\u0432\u0438\u0442\u044c \u0438\u0445 \u0432 \u0441\u043e\u043e\u0442\u0432\u0435\u0442\u0441\u0442\u0432\u0443\u044e\u0449\u0438\u0435 \u043f\u043e\u0437\u0438\u0446\u0438\u0438. \u0415\u0441\u043b\u0438 amount \u043d\u0435 \u043f\u0435\u0440\u0435\u0434\u0430\u043b\u0438, \u0442\u043e \u0437\u0430\u043f\u043e\u043b\u043d\u0438 \u0435\u0433\u043e \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0435\u043c 1.0"}, "temperature": {"_input_type": "MessageTextInput", "advanced": false, "display_name": "Temperature", "dynamic": false, "info": "", "input_types": ["Message"], "list": false, "list_add_label": "Add More", "load_from_db": false, "name": "temperature", "placeholder": "", "required": false, "show": true, "title_case": false, "tool_mode": false, "trace_as_input": true, "trace_as_metadata": true, "type": "str", "value": "0.1"}}, "tool_mode": false}, "showNode": true, "type": "GChatStructured"}, "selected": false, "measured": {"width": 320, "height": 881}, "dragging": false}], "edges": [{"source": "ParserComponent-3T0ZF", "sourceHandle": "{\u0153dataType\u0153:\u0153ParserComponent\u0153,\u0153id\u0153:\u0153ParserComponent-3T0ZF\u0153,\u0153name\u0153:\u0153parsed_text\u0153,\u0153output_types\u0153:[\u0153Message\u0153]}", "target": "CustomComponent-k8AUT", "targetHandle": "{\u0153fieldName\u0153:\u0153year\u0153,\u0153id\u0153:\u0153CustomComponent-k8AUT\u0153,\u0153inputTypes\u0153:[\u0153Message\u0153],\u0153type\u0153:\u0153str\u0153}", "data": {"targetHandle": {"fieldName": "year", "id": "CustomComponent-k8AUT", "inputTypes": ["Message"], "type": "str"}, "sourceHandle": {"dataType": "ParserComponent", "id": "ParserComponent-3T0ZF", "name": "parsed_text", "output_types": ["Message"]}}, "id": "xy-edge__ParserComponent-3T0ZF{\u0153dataType\u0153:\u0153ParserComponent\u0153,\u0153id\u0153:\u0153ParserComponent-3T0ZF\u0153,\u0153name\u0153:\u0153parsed_text\u0153,\u0153output_types\u0153:[\u0153Message\u0153]}-CustomComponent-k8AUT{\u0153fieldName\u0153:\u0153year\u0153,\u0153id\u0153:\u0153CustomComponent-k8AUT\u0153,\u0153inputTypes\u0153:[\u0153Message\u0153],\u0153type\u0153:\u0153str\u0153}", "selected": false, "animated": false, "className": ""}, {"source": "ParserComponent-YCFN7", "sourceHandle": "{\u0153dataType\u0153:\u0153ParserComponent\u0153,\u0153id\u0153:\u0153ParserComponent-YCFN7\u0153,\u0153name\u0153:\u0153parsed_text\u0153,\u0153output_types\u0153:[\u0153Message\u0153]}", "target": "CustomComponent-k8AUT", "targetHandle": "{\u0153fieldName\u0153:\u0153month\u0153,\u0153id\u0153:\u0153CustomComponent-k8AUT\u0153,\u0153inputTypes\u0153:[\u0153Message\u0153],\u0153type\u0153:\u0153str\u0153}", "data": {"targetHandle": {"fieldName": "month", "id": "CustomComponent-k8AUT", "inputTypes": ["Message"], "type": "str"}, "sourceHandle": {"dataType": "ParserComponent", "id": "ParserComponent-YCFN7", "name": "parsed_text", "output_types": ["Message"]}}, "id": "xy-edge__ParserComponent-YCFN7{\u0153dataType\u0153:\u0153ParserComponent\u0153,\u0153id\u0153:\u0153ParserComponent-YCFN7\u0153,\u0153name\u0153:\u0153parsed_text\u0153,\u0153output_types\u0153:[\u0153Message\u0153]}-CustomComponent-k8AUT{\u0153fieldName\u0153:\u0153month\u0153,\u0153id\u0153:\u0153CustomComponent-k8AUT\u0153,\u0153inputTypes\u0153:[\u0153Message\u0153],\u0153type\u0153:\u0153str\u0153}", "selected": false, "animated": false, "className": ""}, {"source": "ParserComponent-ah5TP", "sourceHandle": "{\u0153dataType\u0153:\u0153ParserComponent\u0153,\u0153id\u0153:\u0153ParserComponent-ah5TP\u0153,\u0153name\u0153:\u0153parsed_text\u0153,\u0153output_types\u0153:[\u0153Message\u0153]}", "target": "CustomComponent-k8AUT", "targetHandle": "{\u0153fieldName\u0153:\u0153day\u0153,\u0153id\u0153:\u0153CustomComponent-k8AUT\u0153,\u0153inputTypes\u0153:[\u0153Message\u0153],\u0153type\u0153:\u0153str\u0153}", "data": {"targetHandle": {"fieldName": "day", "id": "CustomComponent-k8AUT", "inputTypes": ["Message"], "type": "str"}, "sourceHandle": {"dataType": "ParserComponent", "id": "ParserComponent-ah5TP", "name": "parsed_text", "output_types": ["Message"]}}, "id": "xy-edge__ParserComponent-ah5TP{\u0153dataType\u0153:\u0153ParserComponent\u0153,\u0153id\u0153:\u0153ParserComponent-ah5TP\u0153,\u0153name\u0153:\u0153parsed_text\u0153,\u0153output_types\u0153:[\u0153Message\u0153]}-CustomComponent-k8AUT{\u0153fieldName\u0153:\u0153day\u0153,\u0153id\u0153:\u0153CustomComponent-k8AUT\u0153,\u0153inputTypes\u0153:[\u0153Message\u0153],\u0153type\u0153:\u0153str\u0153}", "selected": false, "animated": false, "className": ""}, {"source": "ParserComponent-LO6Cp", "sourceHandle": "{\u0153dataType\u0153:\u0153ParserComponent\u0153,\u0153id\u0153:\u0153ParserComponent-LO6Cp\u0153,\u0153name\u0153:\u0153parsed_text\u0153,\u0153output_types\u0153:[\u0153Message\u0153]}", "target": "ConditionalRouter-rdWpU", "targetHandle": "{\u0153fieldName\u0153:\u0153input_text\u0153,\u0153id\u0153:\u0153ConditionalRouter-rdWpU\u0153,\u0153inputTypes\u0153:[\u0153Message\u0153],\u0153type\u0153:\u0153str\u0153}", "data": {"targetHandle": {"fieldName": "input_text", "id": "ConditionalRouter-rdWpU", "inputTypes": ["Message"], "type": "str"}, "sourceHandle": {"dataType": "ParserComponent", "id": "ParserComponent-LO6Cp", "name": "parsed_text", "output_types": ["Message"]}}, "id": "xy-edge__ParserComponent-LO6Cp{\u0153dataType\u0153:\u0153ParserComponent\u0153,\u0153id\u0153:\u0153ParserComponent-LO6Cp\u0153,\u0153name\u0153:\u0153parsed_text\u0153,\u0153output_types\u0153:[\u0153Message\u0153]}-ConditionalRouter-rdWpU{\u0153fieldName\u0153:\u0153input_text\u0153,\u0153id\u0153:\u0153ConditionalRouter-rdWpU\u0153,\u0153inputTypes\u0153:[\u0153Message\u0153],\u0153type\u0153:\u0153str\u0153}", "selected": false, "animated": false, "className": ""}, {"source": "ConditionalRouter-rdWpU", "sourceHandle": "{\u0153dataType\u0153:\u0153ConditionalRouter\u0153,\u0153id\u0153:\u0153ConditionalRouter-rdWpU\u0153,\u0153name\u0153:\u0153false_result\u0153,\u0153output_types\u0153:[\u0153Message\u0153]}", "target": "CustomComponent-4L37T", "targetHandle": "{\u0153fieldName\u0153:\u0153if_else_input\u0153,\u0153id\u0153:\u0153CustomComponent-4L37T\u0153,\u0153inputTypes\u0153:[\u0153str\u0153,\u0153Message\u0153],\u0153type\u0153:\u0153str\u0153}", "data": {"targetHandle": {"fieldName": "if_else_input", "id": "CustomComponent-4L37T", "inputTypes": ["str", "Message"], "type": "str"}, "sourceHandle": {"dataType": "ConditionalRouter", "id": "ConditionalRouter-rdWpU", "name": "false_result", "output_types": ["Message"]}}, "id": "xy-edge__ConditionalRouter-rdWpU{\u0153dataType\u0153:\u0153ConditionalRouter\u0153,\u0153id\u0153:\u0153ConditionalRouter-rdWpU\u0153,\u0153name\u0153:\u0153false_result\u0153,\u0153output_types\u0153:[\u0153Message\u0153]}-CustomComponent-4L37T{\u0153fieldName\u0153:\u0153if_else_input\u0153,\u0153id\u0153:\u0153CustomComponent-4L37T\u0153,\u0153inputTypes\u0153:[\u0153str\u0153,\u0153Message\u0153],\u0153type\u0153:\u0153str\u0153}", "animated": false, "className": "", "selected": false}, {"source": "CustomComponent-4L37T", "sourceHandle": "{\u0153dataType\u0153:\u0153MCPErrorFormatterMessage\u0153,\u0153id\u0153:\u0153CustomComponent-4L37T\u0153,\u0153name\u0153:\u0153output\u0153,\u0153output_types\u0153:[\u0153Message\u0153]}", "target": "ChatOutput-iDlsd", "targetHandle": "{\u0153fieldName\u0153:\u0153input_value\u0153,\u0153id\u0153:\u0153ChatOutput-iDlsd\u0153,\u0153inputTypes\u0153:[\u0153Data\u0153,\u0153DataFrame\u0153,\u0153Message\u0153],\u0153type\u0153:\u0153other\u0153}", "data": {"targetHandle": {"fieldName": "input_value", "id": "ChatOutput-iDlsd", "inputTypes": ["Data", "DataFrame", "Message"], "type": "other"}, "sourceHandle": {"dataType": "MCPErrorFormatterMessage", "id": "CustomComponent-4L37T", "name": "output", "output_types": ["Message"]}}, "id": "xy-edge__CustomComponent-4L37T{\u0153dataType\u0153:\u0153MCPErrorFormatterMessage\u0153,\u0153id\u0153:\u0153CustomComponent-4L37T\u0153,\u0153name\u0153:\u0153output\u0153,\u0153output_types\u0153:[\u0153Message\u0153]}-ChatOutput-iDlsd{\u0153fieldName\u0153:\u0153input_value\u0153,\u0153id\u0153:\u0153ChatOutput-iDlsd\u0153,\u0153inputTypes\u0153:[\u0153Data\u0153,\u0153DataFrame\u0153,\u0153Message\u0153],\u0153type\u0153:\u0153other\u0153}", "animated": false, "className": "", "selected": false}, {"source": "CustomComponent-4L37T", "sourceHandle": "{\u0153dataType\u0153:\u0153MCPErrorFormatterMessage\u0153,\u0153id\u0153:\u0153CustomComponent-4L37T\u0153,\u0153name\u0153:\u0153output\u0153,\u0153output_types\u0153:[\u0153Message\u0153]}", "target": "TextOutput-7yCwt", "targetHandle": "{\u0153fieldName\u0153:\u0153input_value\u0153,\u0153id\u0153:\u0153TextOutput-7yCwt\u0153,\u0153inputTypes\u0153:[\u0153Message\u0153],\u0153type\u0153:\u0153str\u0153}", "data": {"targetHandle": {"fieldName": "input_value", "id": "TextOutput-7yCwt", "inputTypes": ["Message"], "type": "str"}, "sourceHandle": {"dataType": "MCPErrorFormatterMessage", "id": "CustomComponent-4L37T", "name": "output", "output_types": ["Message"]}}, "id": "xy-edge__CustomComponent-4L37T{\u0153dataType\u0153:\u0153MCPErrorFormatterMessage\u0153,\u0153id\u0153:\u0153CustomComponent-4L37T\u0153,\u0153name\u0153:\u0153output\u0153,\u0153output_types\u0153:[\u0153Message\u0153]}-TextOutput-7yCwt{\u0153fieldName\u0153:\u0153input_value\u0153,\u0153id\u0153:\u0153TextOutput-7yCwt\u0153,\u0153inputTypes\u0153:[\u0153Message\u0153],\u0153type\u0153:\u0153str\u0153}", "animated": false, "className": "", "selected": false}, {"source": "ConditionalRouter-rdWpU", "sourceHandle": "{\u0153dataType\u0153:\u0153ConditionalRouter\u0153,\u0153id\u0153:\u0153ConditionalRouter-rdWpU\u0153,\u0153name\u0153:\u0153true_result\u0153,\u0153output_types\u0153:[\u0153Message\u0153]}", "target": "CustomComponent-UuzJ9", "targetHandle": "{\u0153fieldName\u0153:\u0153if_else_input\u0153,\u0153id\u0153:\u0153CustomComponent-UuzJ9\u0153,\u0153inputTypes\u0153:[\u0153str\u0153,\u0153Message\u0153],\u0153type\u0153:\u0153str\u0153}", "data": {"targetHandle": {"fieldName": "if_else_input", "id": "CustomComponent-UuzJ9", "inputTypes": ["str", "Message"], "type": "str"}, "sourceHandle": {"dataType": "ConditionalRouter", "id": "ConditionalRouter-rdWpU", "name": "true_result", "output_types": ["Message"]}}, "id": "xy-edge__ConditionalRouter-rdWpU{\u0153dataType\u0153:\u0153ConditionalRouter\u0153,\u0153id\u0153:\u0153ConditionalRouter-rdWpU\u0153,\u0153name\u0153:\u0153true_result\u0153,\u0153output_types\u0153:[\u0153Message\u0153]}-CustomComponent-UuzJ9{\u0153fieldName\u0153:\u0153if_else_input\u0153,\u0153id\u0153:\u0153CustomComponent-UuzJ9\u0153,\u0153inputTypes\u0153:[\u0153str\u0153,\u0153Message\u0153],\u0153type\u0153:\u0153str\u0153}", "selected": false, "animated": false, "className": ""}, {"source": "ParserComponent-X5CI5", "sourceHandle": "{\u0153dataType\u0153:\u0153ParserComponent\u0153,\u0153id\u0153:\u0153ParserComponent-X5CI5\u0153,\u0153name\u0153:\u0153parsed_text\u0153,\u0153output_types\u0153:[\u0153Message\u0153]}", "target": "CustomComponent-UuzJ9", "targetHandle": "{\u0153fieldName\u0153:\u0153year\u0153,\u0153id\u0153:\u0153CustomComponent-UuzJ9\u0153,\u0153inputTypes\u0153:[\u0153Message\u0153],\u0153type\u0153:\u0153str\u0153}", "data": {"targetHandle": {"fieldName": "year", "id": "CustomComponent-UuzJ9", "inputTypes": ["Message"], "type": "str"}, "sourceHandle": {"dataType": "ParserComponent", "id": "ParserComponent-X5CI5", "name": "parsed_text", "output_types": ["Message"]}}, "id": "xy-edge__ParserComponent-X5CI5{\u0153dataType\u0153:\u0153ParserComponent\u0153,\u0153id\u0153:\u0153ParserComponent-X5CI5\u0153,\u0153name\u0153:\u0153parsed_text\u0153,\u0153output_types\u0153:[\u0153Message\u0153]}-CustomComponent-UuzJ9{\u0153fieldName\u0153:\u0153year\u0153,\u0153id\u0153:\u0153CustomComponent-UuzJ9\u0153,\u0153inputTypes\u0153:[\u0153Message\u0153],\u0153type\u0153:\u0153str\u0153}", "selected": false, "animated": false, "className": ""}, {"source": "ParserComponent-J9XIt", "sourceHandle": "{\u0153dataType\u0153:\u0153ParserComponent\u0153,\u0153id\u0153:\u0153ParserComponent-J9XIt\u0153,\u0153name\u0153:\u0153parsed_text\u0153,\u0153output_types\u0153:[\u0153Message\u0153]}", "target": "CustomComponent-UuzJ9", "targetHandle": "{\u0153fieldName\u0153:\u0153month\u0153,\u0153id\u0153:\u0153CustomComponent-UuzJ9\u0153,\u0153inputTypes\u0153:[\u0153Message\u0153],\u0153type\u0153:\u0153str\u0153}", "data": {"targetHandle": {"fieldName": "month", "id": "CustomComponent-UuzJ9", "inputTypes": ["Message"], "type": "str"}, "sourceHandle": {"dataType": "ParserComponent", "id": "ParserComponent-J9XIt", "name": "parsed_text", "output_types": ["Message"]}}, "id": "xy-edge__ParserComponent-J9XIt{\u0153dataType\u0153:\u0153ParserComponent\u0153,\u0153id\u0153:\u0153ParserComponent-J9XIt\u0153,\u0153name\u0153:\u0153parsed_text\u0153,\u0153output_types\u0153:[\u0153Message\u0153]}-CustomComponent-UuzJ9{\u0153fieldName\u0153:\u0153month\u0153,\u0153id\u0153:\u0153CustomComponent-UuzJ9\u0153,\u0153inputTypes\u0153:[\u0153Message\u0153],\u0153type\u0153:\u0153str\u0153}", "selected": false, "animated": false, "className": ""}, {"source": "ParserComponent-OiKHM", "sourceHandle": "{\u0153dataType\u0153:\u0153ParserComponent\u0153,\u0153id\u0153:\u0153ParserComponent-OiKHM\u0153,\u0153name\u0153:\u0153parsed_text\u0153,\u0153output_types\u0153:[\u0153Message\u0153]}", "target": "CustomComponent-UuzJ9", "targetHandle": "{\u0153fieldName\u0153:\u0153day\u0153,\u0153id\u0153:\u0153CustomComponent-UuzJ9\u0153,\u0153inputTypes\u0153:[\u0153Message\u0153],\u0153type\u0153:\u0153str\u0153}", "data": {"targetHandle": {"fieldName": "day", "id": "CustomComponent-UuzJ9", "inputTypes": ["Message"], "type": "str"}, "sourceHandle": {"dataType": "ParserComponent", "id": "ParserComponent-OiKHM", "name": "parsed_text", "output_types": ["Message"]}}, "id": "xy-edge__ParserComponent-OiKHM{\u0153dataType\u0153:\u0153ParserComponent\u0153,\u0153id\u0153:\u0153ParserComponent-OiKHM\u0153,\u0153name\u0153:\u0153parsed_text\u0153,\u0153output_types\u0153:[\u0153Message\u0153]}-CustomComponent-UuzJ9{\u0153fieldName\u0153:\u0153day\u0153,\u0153id\u0153:\u0153CustomComponent-UuzJ9\u0153,\u0153inputTypes\u0153:[\u0153Message\u0153],\u0153type\u0153:\u0153str\u0153}", "selected": false, "animated": false, "className": ""}, {"source": "CustomComponent-cAc43", "sourceHandle": "{\u0153dataType\u0153:\u0153extract_ymd\u0153,\u0153id\u0153:\u0153CustomComponent-cAc43\u0153,\u0153name\u0153:\u0153date\u0153,\u0153output_types\u0153:[\u0153Data\u0153]}", "target": "ParserComponent-X5CI5", "targetHandle": "{\u0153fieldName\u0153:\u0153input_data\u0153,\u0153id\u0153:\u0153ParserComponent-X5CI5\u0153,\u0153inputTypes\u0153:[\u0153DataFrame\u0153,\u0153Data\u0153],\u0153type\u0153:\u0153other\u0153}", "data": {"targetHandle": {"fieldName": "input_data", "id": "ParserComponent-X5CI5", "inputTypes": ["DataFrame", "Data"], "type": "other"}, "sourceHandle": {"dataType": "extract_ymd", "id": "CustomComponent-cAc43", "name": "date", "output_types": ["Data"]}}, "id": "xy-edge__CustomComponent-cAc43{\u0153dataType\u0153:\u0153extract_ymd\u0153,\u0153id\u0153:\u0153CustomComponent-cAc43\u0153,\u0153name\u0153:\u0153date\u0153,\u0153output_types\u0153:[\u0153Data\u0153]}-ParserComponent-X5CI5{\u0153fieldName\u0153:\u0153input_data\u0153,\u0153id\u0153:\u0153ParserComponent-X5CI5\u0153,\u0153inputTypes\u0153:[\u0153DataFrame\u0153,\u0153Data\u0153],\u0153type\u0153:\u0153other\u0153}", "selected": false, "animated": false, "className": ""}, {"source": "CustomComponent-cAc43", "sourceHandle": "{\u0153dataType\u0153:\u0153extract_ymd\u0153,\u0153id\u0153:\u0153CustomComponent-cAc43\u0153,\u0153name\u0153:\u0153date\u0153,\u0153output_types\u0153:[\u0153Data\u0153]}", "target": "ParserComponent-J9XIt", "targetHandle": "{\u0153fieldName\u0153:\u0153input_data\u0153,\u0153id\u0153:\u0153ParserComponent-J9XIt\u0153,\u0153inputTypes\u0153:[\u0153DataFrame\u0153,\u0153Data\u0153],\u0153type\u0153:\u0153other\u0153}", "data": {"targetHandle": {"fieldName": "input_data", "id": "ParserComponent-J9XIt", "inputTypes": ["DataFrame", "Data"], "type": "other"}, "sourceHandle": {"dataType": "extract_ymd", "id": "CustomComponent-cAc43", "name": "date", "output_types": ["Data"]}}, "id": "xy-edge__CustomComponent-cAc43{\u0153dataType\u0153:\u0153extract_ymd\u0153,\u0153id\u0153:\u0153CustomComponent-cAc43\u0153,\u0153name\u0153:\u0153date\u0153,\u0153output_types\u0153:[\u0153Data\u0153]}-ParserComponent-J9XIt{\u0153fieldName\u0153:\u0153input_data\u0153,\u0153id\u0153:\u0153ParserComponent-J9XIt\u0153,\u0153inputTypes\u0153:[\u0153DataFrame\u0153,\u0153Data\u0153],\u0153type\u0153:\u0153other\u0153}", "selected": false, "animated": false, "className": ""}, {"source": "CustomComponent-cAc43", "sourceHandle": "{\u0153dataType\u0153:\u0153extract_ymd\u0153,\u0153id\u0153:\u0153CustomComponent-cAc43\u0153,\u0153name\u0153:\u0153date\u0153,\u0153output_types\u0153:[\u0153Data\u0153]}", "target": "ParserComponent-OiKHM", "targetHandle": "{\u0153fieldName\u0153:\u0153input_data\u0153,\u0153id\u0153:\u0153ParserComponent-OiKHM\u0153,\u0153inputTypes\u0153:[\u0153DataFrame\u0153,\u0153Data\u0153],\u0153type\u0153:\u0153other\u0153}", "data": {"targetHandle": {"fieldName": "input_data", "id": "ParserComponent-OiKHM", "inputTypes": ["DataFrame", "Data"], "type": "other"}, "sourceHandle": {"dataType": "extract_ymd", "id": "CustomComponent-cAc43", "name": "date", "output_types": ["Data"]}}, "id": "xy-edge__CustomComponent-cAc43{\u0153dataType\u0153:\u0153extract_ymd\u0153,\u0153id\u0153:\u0153CustomComponent-cAc43\u0153,\u0153name\u0153:\u0153date\u0153,\u0153output_types\u0153:[\u0153Data\u0153]}-ParserComponent-OiKHM{\u0153fieldName\u0153:\u0153input_data\u0153,\u0153id\u0153:\u0153ParserComponent-OiKHM\u0153,\u0153inputTypes\u0153:[\u0153DataFrame\u0153,\u0153Data\u0153],\u0153type\u0153:\u0153other\u0153}", "selected": false, "animated": false, "className": ""}, {"source": "ParserComponent-3ZCGm", "sourceHandle": "{\u0153dataType\u0153:\u0153ParserComponent\u0153,\u0153id\u0153:\u0153ParserComponent-3ZCGm\u0153,\u0153name\u0153:\u0153parsed_text\u0153,\u0153output_types\u0153:[\u0153Message\u0153]}", "target": "CustomComponent-UuzJ9", "targetHandle": "{\u0153fieldName\u0153:\u0153amount\u0153,\u0153id\u0153:\u0153CustomComponent-UuzJ9\u0153,\u0153inputTypes\u0153:[\u0153Message\u0153],\u0153type\u0153:\u0153str\u0153}", "data": {"targetHandle": {"fieldName": "amount", "id": "CustomComponent-UuzJ9", "inputTypes": ["Message"], "type": "str"}, "sourceHandle": {"dataType": "ParserComponent", "id": "ParserComponent-3ZCGm", "name": "parsed_text", "output_types": ["Message"]}}, "id": "xy-edge__ParserComponent-3ZCGm{\u0153dataType\u0153:\u0153ParserComponent\u0153,\u0153id\u0153:\u0153ParserComponent-3ZCGm\u0153,\u0153name\u0153:\u0153parsed_text\u0153,\u0153output_types\u0153:[\u0153Message\u0153]}-CustomComponent-UuzJ9{\u0153fieldName\u0153:\u0153amount\u0153,\u0153id\u0153:\u0153CustomComponent-UuzJ9\u0153,\u0153inputTypes\u0153:[\u0153Message\u0153],\u0153type\u0153:\u0153str\u0153}", "selected": false, "animated": false, "className": ""}, {"source": "CustomComponent-UuzJ9", "sourceHandle": "{\u0153dataType\u0153:\u0153CBRHistoricalConverter\u0153,\u0153id\u0153:\u0153CustomComponent-UuzJ9\u0153,\u0153name\u0153:\u0153output\u0153,\u0153output_types\u0153:[\u0153Data\u0153]}", "target": "CustomComponent-IdtOy", "targetHandle": "{\u0153fieldName\u0153:\u0153payload\u0153,\u0153id\u0153:\u0153CustomComponent-IdtOy\u0153,\u0153inputTypes\u0153:[\u0153Data\u0153,\u0153str\u0153,\u0153Message\u0153],\u0153type\u0153:\u0153str\u0153}", "data": {"targetHandle": {"fieldName": "payload", "id": "CustomComponent-IdtOy", "inputTypes": ["Data", "str", "Message"], "type": "str"}, "sourceHandle": {"dataType": "CBRHistoricalConverter", "id": "CustomComponent-UuzJ9", "name": "output", "output_types": ["Data"]}}, "id": "xy-edge__CustomComponent-UuzJ9{\u0153dataType\u0153:\u0153CBRHistoricalConverter\u0153,\u0153id\u0153:\u0153CustomComponent-UuzJ9\u0153,\u0153name\u0153:\u0153output\u0153,\u0153output_types\u0153:[\u0153Data\u0153]}-CustomComponent-IdtOy{\u0153fieldName\u0153:\u0153payload\u0153,\u0153id\u0153:\u0153CustomComponent-IdtOy\u0153,\u0153inputTypes\u0153:[\u0153Data\u0153,\u0153str\u0153,\u0153Message\u0153],\u0153type\u0153:\u0153str\u0153}", "selected": false, "animated": false, "className": ""}, {"source": "CustomComponent-IdtOy", "sourceHandle": "{\u0153dataType\u0153:\u0153CBRMessageFormatter\u0153,\u0153id\u0153:\u0153CustomComponent-IdtOy\u0153,\u0153name\u0153:\u0153output\u0153,\u0153output_types\u0153:[\u0153Message\u0153]}", "target": "ChatOutput-TKTFg", "targetHandle": "{\u0153fieldName\u0153:\u0153input_value\u0153,\u0153id\u0153:\u0153ChatOutput-TKTFg\u0153,\u0153inputTypes\u0153:[\u0153Data\u0153,\u0153DataFrame\u0153,\u0153Message\u0153],\u0153type\u0153:\u0153other\u0153}", "data": {"targetHandle": {"fieldName": "input_value", "id": "ChatOutput-TKTFg", "inputTypes": ["Data", "DataFrame", "Message"], "type": "other"}, "sourceHandle": {"dataType": "CBRMessageFormatter", "id": "CustomComponent-IdtOy", "name": "output", "output_types": ["Message"]}}, "id": "xy-edge__CustomComponent-IdtOy{\u0153dataType\u0153:\u0153CBRMessageFormatter\u0153,\u0153id\u0153:\u0153CustomComponent-IdtOy\u0153,\u0153name\u0153:\u0153output\u0153,\u0153output_types\u0153:[\u0153Message\u0153]}-ChatOutput-TKTFg{\u0153fieldName\u0153:\u0153input_value\u0153,\u0153id\u0153:\u0153ChatOutput-TKTFg\u0153,\u0153inputTypes\u0153:[\u0153Data\u0153,\u0153DataFrame\u0153,\u0153Message\u0153],\u0153type\u0153:\u0153other\u0153}", "animated": false, "className": "", "selected": false}, {"source": "ParserComponent-XCoyO", "sourceHandle": "{\u0153dataType\u0153:\u0153ParserComponent\u0153,\u0153id\u0153:\u0153ParserComponent-XCoyO\u0153,\u0153name\u0153:\u0153parsed_text\u0153,\u0153output_types\u0153:[\u0153Message\u0153]}", "target": "CustomComponent-k8AUT", "targetHandle": "{\u0153fieldName\u0153:\u0153base_currency\u0153,\u0153id\u0153:\u0153CustomComponent-k8AUT\u0153,\u0153inputTypes\u0153:[\u0153str\u0153,\u0153Message\u0153],\u0153type\u0153:\u0153str\u0153}", "data": {"targetHandle": {"fieldName": "base_currency", "id": "CustomComponent-k8AUT", "inputTypes": ["str", "Message"], "type": "str"}, "sourceHandle": {"dataType": "ParserComponent", "id": "ParserComponent-XCoyO", "name": "parsed_text", "output_types": ["Message"]}}, "id": "xy-edge__ParserComponent-XCoyO{\u0153dataType\u0153:\u0153ParserComponent\u0153,\u0153id\u0153:\u0153ParserComponent-XCoyO\u0153,\u0153name\u0153:\u0153parsed_text\u0153,\u0153output_types\u0153:[\u0153Message\u0153]}-CustomComponent-k8AUT{\u0153fieldName\u0153:\u0153base_currency\u0153,\u0153id\u0153:\u0153CustomComponent-k8AUT\u0153,\u0153inputTypes\u0153:[\u0153str\u0153,\u0153Message\u0153],\u0153type\u0153:\u0153str\u0153}", "selected": false, "animated": false, "className": ""}, {"source": "ParserComponent-47fqI", "sourceHandle": "{\u0153dataType\u0153:\u0153ParserComponent\u0153,\u0153id\u0153:\u0153ParserComponent-47fqI\u0153,\u0153name\u0153:\u0153parsed_text\u0153,\u0153output_types\u0153:[\u0153Message\u0153]}", "target": "CustomComponent-k8AUT", "targetHandle": "{\u0153fieldName\u0153:\u0153target_currency\u0153,\u0153id\u0153:\u0153CustomComponent-k8AUT\u0153,\u0153inputTypes\u0153:[\u0153str\u0153,\u0153Message\u0153],\u0153type\u0153:\u0153str\u0153}", "data": {"targetHandle": {"fieldName": "target_currency", "id": "CustomComponent-k8AUT", "inputTypes": ["str", "Message"], "type": "str"}, "sourceHandle": {"dataType": "ParserComponent", "id": "ParserComponent-47fqI", "name": "parsed_text", "output_types": ["Message"]}}, "id": "xy-edge__ParserComponent-47fqI{\u0153dataType\u0153:\u0153ParserComponent\u0153,\u0153id\u0153:\u0153ParserComponent-47fqI\u0153,\u0153name\u0153:\u0153parsed_text\u0153,\u0153output_types\u0153:[\u0153Message\u0153]}-CustomComponent-k8AUT{\u0153fieldName\u0153:\u0153target_currency\u0153,\u0153id\u0153:\u0153CustomComponent-k8AUT\u0153,\u0153inputTypes\u0153:[\u0153str\u0153,\u0153Message\u0153],\u0153type\u0153:\u0153str\u0153}", "selected": false, "animated": false, "className": ""}, {"source": "CustomComponent-k8AUT", "sourceHandle": "{\u0153dataType\u0153:\u0153CheckCurrencyAndDate\u0153,\u0153id\u0153:\u0153CustomComponent-k8AUT\u0153,\u0153name\u0153:\u0153output\u0153,\u0153output_types\u0153:[\u0153Data\u0153]}", "target": "ParserComponent-LO6Cp", "targetHandle": "{\u0153fieldName\u0153:\u0153input_data\u0153,\u0153id\u0153:\u0153ParserComponent-LO6Cp\u0153,\u0153inputTypes\u0153:[\u0153DataFrame\u0153,\u0153Data\u0153],\u0153type\u0153:\u0153other\u0153}", "data": {"targetHandle": {"fieldName": "input_data", "id": "ParserComponent-LO6Cp", "inputTypes": ["DataFrame", "Data"], "type": "other"}, "sourceHandle": {"dataType": "CheckCurrencyAndDate", "id": "CustomComponent-k8AUT", "name": "output", "output_types": ["Data"]}}, "id": "xy-edge__CustomComponent-k8AUT{\u0153dataType\u0153:\u0153CheckCurrencyAndDate\u0153,\u0153id\u0153:\u0153CustomComponent-k8AUT\u0153,\u0153name\u0153:\u0153output\u0153,\u0153output_types\u0153:[\u0153Data\u0153]}-ParserComponent-LO6Cp{\u0153fieldName\u0153:\u0153input_data\u0153,\u0153id\u0153:\u0153ParserComponent-LO6Cp\u0153,\u0153inputTypes\u0153:[\u0153DataFrame\u0153,\u0153Data\u0153],\u0153type\u0153:\u0153other\u0153}", "animated": false, "className": "", "selected": false}, {"source": "LoadJSON-yTqey", "sourceHandle": "{\u0153dataType\u0153:\u0153LoadJSON\u0153,\u0153id\u0153:\u0153LoadJSON-yTqey\u0153,\u0153name\u0153:\u0153output\u0153,\u0153output_types\u0153:[\u0153Data\u0153]}", "target": "CustomComponent-k8AUT", "targetHandle": "{\u0153fieldName\u0153:\u0153currency_dict\u0153,\u0153id\u0153:\u0153CustomComponent-k8AUT\u0153,\u0153inputTypes\u0153:[\u0153Data\u0153],\u0153type\u0153:\u0153other\u0153}", "data": {"targetHandle": {"fieldName": "currency_dict", "id": "CustomComponent-k8AUT", "inputTypes": ["Data"], "type": "other"}, "sourceHandle": {"dataType": "LoadJSON", "id": "LoadJSON-yTqey", "name": "output", "output_types": ["Data"]}}, "id": "xy-edge__LoadJSON-yTqey{\u0153dataType\u0153:\u0153LoadJSON\u0153,\u0153id\u0153:\u0153LoadJSON-yTqey\u0153,\u0153name\u0153:\u0153output\u0153,\u0153output_types\u0153:[\u0153Data\u0153]}-CustomComponent-k8AUT{\u0153fieldName\u0153:\u0153currency_dict\u0153,\u0153id\u0153:\u0153CustomComponent-k8AUT\u0153,\u0153inputTypes\u0153:[\u0153Data\u0153],\u0153type\u0153:\u0153other\u0153}", "animated": false, "className": "", "selected": false}, {"source": "CustomComponent-k8AUT", "sourceHandle": "{\u0153dataType\u0153:\u0153CheckCurrencyAndDate\u0153,\u0153id\u0153:\u0153CustomComponent-k8AUT\u0153,\u0153name\u0153:\u0153output\u0153,\u0153output_types\u0153:[\u0153Data\u0153]}", "target": "CustomComponent-cAc43", "targetHandle": "{\u0153fieldName\u0153:\u0153input_value\u0153,\u0153id\u0153:\u0153CustomComponent-cAc43\u0153,\u0153inputTypes\u0153:[\u0153Data\u0153],\u0153type\u0153:\u0153other\u0153}", "data": {"targetHandle": {"fieldName": "input_value", "id": "CustomComponent-cAc43", "inputTypes": ["Data"], "type": "other"}, "sourceHandle": {"dataType": "CheckCurrencyAndDate", "id": "CustomComponent-k8AUT", "name": "output", "output_types": ["Data"]}}, "id": "xy-edge__CustomComponent-k8AUT{\u0153dataType\u0153:\u0153CheckCurrencyAndDate\u0153,\u0153id\u0153:\u0153CustomComponent-k8AUT\u0153,\u0153name\u0153:\u0153output\u0153,\u0153output_types\u0153:[\u0153Data\u0153]}-CustomComponent-cAc43{\u0153fieldName\u0153:\u0153input_value\u0153,\u0153id\u0153:\u0153CustomComponent-cAc43\u0153,\u0153inputTypes\u0153:[\u0153Data\u0153],\u0153type\u0153:\u0153other\u0153}", "animated": false, "className": "", "selected": false}, {"source": "CustomComponent-k8AUT", "sourceHandle": "{\u0153dataType\u0153:\u0153CheckCurrencyAndDate\u0153,\u0153id\u0153:\u0153CustomComponent-k8AUT\u0153,\u0153name\u0153:\u0153output\u0153,\u0153output_types\u0153:[\u0153Data\u0153]}", "target": "CustomComponent-ttERH", "targetHandle": "{\u0153fieldName\u0153:\u0153input_value\u0153,\u0153id\u0153:\u0153CustomComponent-ttERH\u0153,\u0153inputTypes\u0153:[\u0153Data\u0153],\u0153type\u0153:\u0153other\u0153}", "data": {"targetHandle": {"fieldName": "input_value", "id": "CustomComponent-ttERH", "inputTypes": ["Data"], "type": "other"}, "sourceHandle": {"dataType": "CheckCurrencyAndDate", "id": "CustomComponent-k8AUT", "name": "output", "output_types": ["Data"]}}, "id": "xy-edge__CustomComponent-k8AUT{\u0153dataType\u0153:\u0153CheckCurrencyAndDate\u0153,\u0153id\u0153:\u0153CustomComponent-k8AUT\u0153,\u0153name\u0153:\u0153output\u0153,\u0153output_types\u0153:[\u0153Data\u0153]}-CustomComponent-ttERH{\u0153fieldName\u0153:\u0153input_value\u0153,\u0153id\u0153:\u0153CustomComponent-ttERH\u0153,\u0153inputTypes\u0153:[\u0153Data\u0153],\u0153type\u0153:\u0153other\u0153}", "animated": false, "className": "", "selected": false}, {"source": "CustomComponent-ttERH", "sourceHandle": "{\u0153dataType\u0153:\u0153extract_codes\u0153,\u0153id\u0153:\u0153CustomComponent-ttERH\u0153,\u0153name\u0153:\u0153date\u0153,\u0153output_types\u0153:[\u0153Data\u0153]}", "target": "ParserComponent-Cwab2", "targetHandle": "{\u0153fieldName\u0153:\u0153input_data\u0153,\u0153id\u0153:\u0153ParserComponent-Cwab2\u0153,\u0153inputTypes\u0153:[\u0153DataFrame\u0153,\u0153Data\u0153],\u0153type\u0153:\u0153other\u0153}", "data": {"targetHandle": {"fieldName": "input_data", "id": "ParserComponent-Cwab2", "inputTypes": ["DataFrame", "Data"], "type": "other"}, "sourceHandle": {"dataType": "extract_codes", "id": "CustomComponent-ttERH", "name": "date", "output_types": ["Data"]}}, "id": "xy-edge__CustomComponent-ttERH{\u0153dataType\u0153:\u0153extract_codes\u0153,\u0153id\u0153:\u0153CustomComponent-ttERH\u0153,\u0153name\u0153:\u0153date\u0153,\u0153output_types\u0153:[\u0153Data\u0153]}-ParserComponent-Cwab2{\u0153fieldName\u0153:\u0153input_data\u0153,\u0153id\u0153:\u0153ParserComponent-Cwab2\u0153,\u0153inputTypes\u0153:[\u0153DataFrame\u0153,\u0153Data\u0153],\u0153type\u0153:\u0153other\u0153}", "selected": false, "animated": false, "className": ""}, {"source": "CustomComponent-ttERH", "sourceHandle": "{\u0153dataType\u0153:\u0153extract_codes\u0153,\u0153id\u0153:\u0153CustomComponent-ttERH\u0153,\u0153name\u0153:\u0153date\u0153,\u0153output_types\u0153:[\u0153Data\u0153]}", "target": "ParserComponent-cWwBx", "targetHandle": "{\u0153fieldName\u0153:\u0153input_data\u0153,\u0153id\u0153:\u0153ParserComponent-cWwBx\u0153,\u0153inputTypes\u0153:[\u0153DataFrame\u0153,\u0153Data\u0153],\u0153type\u0153:\u0153other\u0153}", "data": {"targetHandle": {"fieldName": "input_data", "id": "ParserComponent-cWwBx", "inputTypes": ["DataFrame", "Data"], "type": "other"}, "sourceHandle": {"dataType": "extract_codes", "id": "CustomComponent-ttERH", "name": "date", "output_types": ["Data"]}}, "id": "xy-edge__CustomComponent-ttERH{\u0153dataType\u0153:\u0153extract_codes\u0153,\u0153id\u0153:\u0153CustomComponent-ttERH\u0153,\u0153name\u0153:\u0153date\u0153,\u0153output_types\u0153:[\u0153Data\u0153]}-ParserComponent-cWwBx{\u0153fieldName\u0153:\u0153input_data\u0153,\u0153id\u0153:\u0153ParserComponent-cWwBx\u0153,\u0153inputTypes\u0153:[\u0153DataFrame\u0153,\u0153Data\u0153],\u0153type\u0153:\u0153other\u0153}", "selected": false, "animated": false, "className": ""}, {"source": "ParserComponent-cWwBx", "sourceHandle": "{\u0153dataType\u0153:\u0153ParserComponent\u0153,\u0153id\u0153:\u0153ParserComponent-cWwBx\u0153,\u0153name\u0153:\u0153parsed_text\u0153,\u0153output_types\u0153:[\u0153Message\u0153]}", "target": "CustomComponent-UuzJ9", "targetHandle": "{\u0153fieldName\u0153:\u0153base_currency\u0153,\u0153id\u0153:\u0153CustomComponent-UuzJ9\u0153,\u0153inputTypes\u0153:[\u0153Message\u0153],\u0153type\u0153:\u0153str\u0153}", "data": {"targetHandle": {"fieldName": "base_currency", "id": "CustomComponent-UuzJ9", "inputTypes": ["Message"], "type": "str"}, "sourceHandle": {"dataType": "ParserComponent", "id": "ParserComponent-cWwBx", "name": "parsed_text", "output_types": ["Message"]}}, "id": "xy-edge__ParserComponent-cWwBx{\u0153dataType\u0153:\u0153ParserComponent\u0153,\u0153id\u0153:\u0153ParserComponent-cWwBx\u0153,\u0153name\u0153:\u0153parsed_text\u0153,\u0153output_types\u0153:[\u0153Message\u0153]}-CustomComponent-UuzJ9{\u0153fieldName\u0153:\u0153base_currency\u0153,\u0153id\u0153:\u0153CustomComponent-UuzJ9\u0153,\u0153inputTypes\u0153:[\u0153Message\u0153],\u0153type\u0153:\u0153str\u0153}", "selected": false, "animated": false, "className": ""}, {"source": "ParserComponent-Cwab2", "sourceHandle": "{\u0153dataType\u0153:\u0153ParserComponent\u0153,\u0153id\u0153:\u0153ParserComponent-Cwab2\u0153,\u0153name\u0153:\u0153parsed_text\u0153,\u0153output_types\u0153:[\u0153Message\u0153]}", "target": "CustomComponent-UuzJ9", "targetHandle": "{\u0153fieldName\u0153:\u0153target_currency\u0153,\u0153id\u0153:\u0153CustomComponent-UuzJ9\u0153,\u0153inputTypes\u0153:[\u0153Message\u0153],\u0153type\u0153:\u0153str\u0153}", "data": {"targetHandle": {"fieldName": "target_currency", "id": "CustomComponent-UuzJ9", "inputTypes": ["Message"], "type": "str"}, "sourceHandle": {"dataType": "ParserComponent", "id": "ParserComponent-Cwab2", "name": "parsed_text", "output_types": ["Message"]}}, "id": "xy-edge__ParserComponent-Cwab2{\u0153dataType\u0153:\u0153ParserComponent\u0153,\u0153id\u0153:\u0153ParserComponent-Cwab2\u0153,\u0153name\u0153:\u0153parsed_text\u0153,\u0153output_types\u0153:[\u0153Message\u0153]}-CustomComponent-UuzJ9{\u0153fieldName\u0153:\u0153target_currency\u0153,\u0153id\u0153:\u0153CustomComponent-UuzJ9\u0153,\u0153inputTypes\u0153:[\u0153Message\u0153],\u0153type\u0153:\u0153str\u0153}", "selected": false, "animated": false, "className": ""}, {"source": "CustomComponent-k8AUT", "sourceHandle": "{\u0153dataType\u0153:\u0153CheckCurrencyAndDate\u0153,\u0153id\u0153:\u0153CustomComponent-k8AUT\u0153,\u0153name\u0153:\u0153output\u0153,\u0153output_types\u0153:[\u0153Data\u0153]}", "target": "CustomComponent-4L37T", "targetHandle": "{\u0153fieldName\u0153:\u0153result_data\u0153,\u0153id\u0153:\u0153CustomComponent-4L37T\u0153,\u0153inputTypes\u0153:[\u0153Data\u0153],\u0153type\u0153:\u0153other\u0153}", "data": {"targetHandle": {"fieldName": "result_data", "id": "CustomComponent-4L37T", "inputTypes": ["Data"], "type": "other"}, "sourceHandle": {"dataType": "CheckCurrencyAndDate", "id": "CustomComponent-k8AUT", "name": "output", "output_types": ["Data"]}}, "id": "xy-edge__CustomComponent-k8AUT{\u0153dataType\u0153:\u0153CheckCurrencyAndDate\u0153,\u0153id\u0153:\u0153CustomComponent-k8AUT\u0153,\u0153name\u0153:\u0153output\u0153,\u0153output_types\u0153:[\u0153Data\u0153]}-CustomComponent-4L37T{\u0153fieldName\u0153:\u0153result_data\u0153,\u0153id\u0153:\u0153CustomComponent-4L37T\u0153,\u0153inputTypes\u0153:[\u0153Data\u0153],\u0153type\u0153:\u0153other\u0153}", "animated": false, "className": "", "selected": false}, {"source": "ChatInput-a3rZn", "sourceHandle": "{\u0153dataType\u0153:\u0153ChatInput\u0153,\u0153id\u0153:\u0153ChatInput-a3rZn\u0153,\u0153name\u0153:\u0153message\u0153,\u0153output_types\u0153:[\u0153Message\u0153]}", "target": "GChatStructured-p3gif", "targetHandle": "{\u0153fieldName\u0153:\u0153input_message\u0153,\u0153id\u0153:\u0153GChatStructured-p3gif\u0153,\u0153inputTypes\u0153:[\u0153Message\u0153],\u0153type\u0153:\u0153str\u0153}", "data": {"targetHandle": {"fieldName": "input_message", "id": "GChatStructured-p3gif", "inputTypes": ["Message"], "type": "str"}, "sourceHandle": {"dataType": "ChatInput", "id": "ChatInput-a3rZn", "name": "message", "output_types": ["Message"]}}, "id": "xy-edge__ChatInput-a3rZn{\u0153dataType\u0153:\u0153ChatInput\u0153,\u0153id\u0153:\u0153ChatInput-a3rZn\u0153,\u0153name\u0153:\u0153message\u0153,\u0153output_types\u0153:[\u0153Message\u0153]}-GChatStructured-p3gif{\u0153fieldName\u0153:\u0153input_message\u0153,\u0153id\u0153:\u0153GChatStructured-p3gif\u0153,\u0153inputTypes\u0153:[\u0153Message\u0153],\u0153type\u0153:\u0153str\u0153}", "selected": false, "animated": false, "className": ""}, {"source": "GetEnvVar-uYtCL", "sourceHandle": "{\u0153dataType\u0153:\u0153GetEnvVar\u0153,\u0153id\u0153:\u0153GetEnvVar-uYtCL\u0153,\u0153name\u0153:\u0153env_var_value\u0153,\u0153output_types\u0153:[\u0153Message\u0153]}", "target": "GChatStructured-p3gif", "targetHandle": "{\u0153fieldName\u0153:\u0153giga_api\u0153,\u0153id\u0153:\u0153GChatStructured-p3gif\u0153,\u0153inputTypes\u0153:[\u0153str\u0153,\u0153Message\u0153],\u0153type\u0153:\u0153str\u0153}", "data": {"targetHandle": {"fieldName": "giga_api", "id": "GChatStructured-p3gif", "inputTypes": ["str", "Message"], "type": "str"}, "sourceHandle": {"dataType": "GetEnvVar", "id": "GetEnvVar-uYtCL", "name": "env_var_value", "output_types": ["Message"]}}, "id": "xy-edge__GetEnvVar-uYtCL{\u0153dataType\u0153:\u0153GetEnvVar\u0153,\u0153id\u0153:\u0153GetEnvVar-uYtCL\u0153,\u0153name\u0153:\u0153env_var_value\u0153,\u0153output_types\u0153:[\u0153Message\u0153]}-GChatStructured-p3gif{\u0153fieldName\u0153:\u0153giga_api\u0153,\u0153id\u0153:\u0153GChatStructured-p3gif\u0153,\u0153inputTypes\u0153:[\u0153str\u0153,\u0153Message\u0153],\u0153type\u0153:\u0153str\u0153}", "selected": false, "animated": false, "className": ""}, {"source": "GChatStructured-p3gif", "sourceHandle": "{\u0153dataType\u0153:\u0153GChatStructured\u0153,\u0153id\u0153:\u0153GChatStructured-p3gif\u0153,\u0153name\u0153:\u0153output\u0153,\u0153output_types\u0153:[\u0153Data\u0153]}", "target": "TextOutput-g3ixe", "targetHandle": "{\u0153fieldName\u0153:\u0153input_value\u0153,\u0153id\u0153:\u0153TextOutput-g3ixe\u0153,\u0153inputTypes\u0153:[\u0153Data\u0153],\u0153type\u0153:\u0153other\u0153}", "data": {"targetHandle": {"fieldName": "input_value", "id": "TextOutput-g3ixe", "inputTypes": ["Data"], "type": "other"}, "sourceHandle": {"dataType": "GChatStructured", "id": "GChatStructured-p3gif", "name": "output", "output_types": ["Data"]}}, "id": "xy-edge__GChatStructured-p3gif{\u0153dataType\u0153:\u0153GChatStructured\u0153,\u0153id\u0153:\u0153GChatStructured-p3gif\u0153,\u0153name\u0153:\u0153output\u0153,\u0153output_types\u0153:[\u0153Data\u0153]}-TextOutput-g3ixe{\u0153fieldName\u0153:\u0153input_value\u0153,\u0153id\u0153:\u0153TextOutput-g3ixe\u0153,\u0153inputTypes\u0153:[\u0153Data\u0153],\u0153type\u0153:\u0153other\u0153}", "selected": false, "animated": false, "className": ""}, {"source": "GChatStructured-p3gif", "sourceHandle": "{\u0153dataType\u0153:\u0153GChatStructured\u0153,\u0153id\u0153:\u0153GChatStructured-p3gif\u0153,\u0153name\u0153:\u0153output\u0153,\u0153output_types\u0153:[\u0153Data\u0153]}", "target": "ParserComponent-3T0ZF", "targetHandle": "{\u0153fieldName\u0153:\u0153input_data\u0153,\u0153id\u0153:\u0153ParserComponent-3T0ZF\u0153,\u0153inputTypes\u0153:[\u0153DataFrame\u0153,\u0153Data\u0153],\u0153type\u0153:\u0153other\u0153}", "data": {"targetHandle": {"fieldName": "input_data", "id": "ParserComponent-3T0ZF", "inputTypes": ["DataFrame", "Data"], "type": "other"}, "sourceHandle": {"dataType": "GChatStructured", "id": "GChatStructured-p3gif", "name": "output", "output_types": ["Data"]}}, "id": "xy-edge__GChatStructured-p3gif{\u0153dataType\u0153:\u0153GChatStructured\u0153,\u0153id\u0153:\u0153GChatStructured-p3gif\u0153,\u0153name\u0153:\u0153output\u0153,\u0153output_types\u0153:[\u0153Data\u0153]}-ParserComponent-3T0ZF{\u0153fieldName\u0153:\u0153input_data\u0153,\u0153id\u0153:\u0153ParserComponent-3T0ZF\u0153,\u0153inputTypes\u0153:[\u0153DataFrame\u0153,\u0153Data\u0153],\u0153type\u0153:\u0153other\u0153}", "selected": false, "animated": false, "className": ""}, {"source": "GChatStructured-p3gif", "sourceHandle": "{\u0153dataType\u0153:\u0153GChatStructured\u0153,\u0153id\u0153:\u0153GChatStructured-p3gif\u0153,\u0153name\u0153:\u0153output\u0153,\u0153output_types\u0153:[\u0153Data\u0153]}", "target": "ParserComponent-YCFN7", "targetHandle": "{\u0153fieldName\u0153:\u0153input_data\u0153,\u0153id\u0153:\u0153ParserComponent-YCFN7\u0153,\u0153inputTypes\u0153:[\u0153DataFrame\u0153,\u0153Data\u0153],\u0153type\u0153:\u0153other\u0153}", "data": {"targetHandle": {"fieldName": "input_data", "id": "ParserComponent-YCFN7", "inputTypes": ["DataFrame", "Data"], "type": "other"}, "sourceHandle": {"dataType": "GChatStructured", "id": "GChatStructured-p3gif", "name": "output", "output_types": ["Data"]}}, "id": "xy-edge__GChatStructured-p3gif{\u0153dataType\u0153:\u0153GChatStructured\u0153,\u0153id\u0153:\u0153GChatStructured-p3gif\u0153,\u0153name\u0153:\u0153output\u0153,\u0153output_types\u0153:[\u0153Data\u0153]}-ParserComponent-YCFN7{\u0153fieldName\u0153:\u0153input_data\u0153,\u0153id\u0153:\u0153ParserComponent-YCFN7\u0153,\u0153inputTypes\u0153:[\u0153DataFrame\u0153,\u0153Data\u0153],\u0153type\u0153:\u0153other\u0153}", "selected": false, "animated": false, "className": ""}, {"source": "GChatStructured-p3gif", "sourceHandle": "{\u0153dataType\u0153:\u0153GChatStructured\u0153,\u0153id\u0153:\u0153GChatStructured-p3gif\u0153,\u0153name\u0153:\u0153output\u0153,\u0153output_types\u0153:[\u0153Data\u0153]}", "target": "ParserComponent-ah5TP", "targetHandle": "{\u0153fieldName\u0153:\u0153input_data\u0153,\u0153id\u0153:\u0153ParserComponent-ah5TP\u0153,\u0153inputTypes\u0153:[\u0153DataFrame\u0153,\u0153Data\u0153],\u0153type\u0153:\u0153other\u0153}", "data": {"targetHandle": {"fieldName": "input_data", "id": "ParserComponent-ah5TP", "inputTypes": ["DataFrame", "Data"], "type": "other"}, "sourceHandle": {"dataType": "GChatStructured", "id": "GChatStructured-p3gif", "name": "output", "output_types": ["Data"]}}, "id": "xy-edge__GChatStructured-p3gif{\u0153dataType\u0153:\u0153GChatStructured\u0153,\u0153id\u0153:\u0153GChatStructured-p3gif\u0153,\u0153name\u0153:\u0153output\u0153,\u0153output_types\u0153:[\u0153Data\u0153]}-ParserComponent-ah5TP{\u0153fieldName\u0153:\u0153input_data\u0153,\u0153id\u0153:\u0153ParserComponent-ah5TP\u0153,\u0153inputTypes\u0153:[\u0153DataFrame\u0153,\u0153Data\u0153],\u0153type\u0153:\u0153other\u0153}", "selected": false, "animated": false, "className": ""}, {"source": "GChatStructured-p3gif", "sourceHandle": "{\u0153dataType\u0153:\u0153GChatStructured\u0153,\u0153id\u0153:\u0153GChatStructured-p3gif\u0153,\u0153name\u0153:\u0153output\u0153,\u0153output_types\u0153:[\u0153Data\u0153]}", "target": "ParserComponent-XCoyO", "targetHandle": "{\u0153fieldName\u0153:\u0153input_data\u0153,\u0153id\u0153:\u0153ParserComponent-XCoyO\u0153,\u0153inputTypes\u0153:[\u0153DataFrame\u0153,\u0153Data\u0153],\u0153type\u0153:\u0153other\u0153}", "data": {"targetHandle": {"fieldName": "input_data", "id": "ParserComponent-XCoyO", "inputTypes": ["DataFrame", "Data"], "type": "other"}, "sourceHandle": {"dataType": "GChatStructured", "id": "GChatStructured-p3gif", "name": "output", "output_types": ["Data"]}}, "id": "xy-edge__GChatStructured-p3gif{\u0153dataType\u0153:\u0153GChatStructured\u0153,\u0153id\u0153:\u0153GChatStructured-p3gif\u0153,\u0153name\u0153:\u0153output\u0153,\u0153output_types\u0153:[\u0153Data\u0153]}-ParserComponent-XCoyO{\u0153fieldName\u0153:\u0153input_data\u0153,\u0153id\u0153:\u0153ParserComponent-XCoyO\u0153,\u0153inputTypes\u0153:[\u0153DataFrame\u0153,\u0153Data\u0153],\u0153type\u0153:\u0153other\u0153}", "selected": false, "animated": false, "className": ""}, {"source": "GChatStructured-p3gif", "sourceHandle": "{\u0153dataType\u0153:\u0153GChatStructured\u0153,\u0153id\u0153:\u0153GChatStructured-p3gif\u0153,\u0153name\u0153:\u0153output\u0153,\u0153output_types\u0153:[\u0153Data\u0153]}", "target": "ParserComponent-47fqI", "targetHandle": "{\u0153fieldName\u0153:\u0153input_data\u0153,\u0153id\u0153:\u0153ParserComponent-47fqI\u0153,\u0153inputTypes\u0153:[\u0153DataFrame\u0153,\u0153Data\u0153],\u0153type\u0153:\u0153other\u0153}", "data": {"targetHandle": {"fieldName": "input_data", "id": "ParserComponent-47fqI", "inputTypes": ["DataFrame", "Data"], "type": "other"}, "sourceHandle": {"dataType": "GChatStructured", "id": "GChatStructured-p3gif", "name": "output", "output_types": ["Data"]}}, "id": "xy-edge__GChatStructured-p3gif{\u0153dataType\u0153:\u0153GChatStructured\u0153,\u0153id\u0153:\u0153GChatStructured-p3gif\u0153,\u0153name\u0153:\u0153output\u0153,\u0153output_types\u0153:[\u0153Data\u0153]}-ParserComponent-47fqI{\u0153fieldName\u0153:\u0153input_data\u0153,\u0153id\u0153:\u0153ParserComponent-47fqI\u0153,\u0153inputTypes\u0153:[\u0153DataFrame\u0153,\u0153Data\u0153],\u0153type\u0153:\u0153other\u0153}", "selected": false, "animated": false, "className": ""}, {"source": "GChatStructured-p3gif", "sourceHandle": "{\u0153dataType\u0153:\u0153GChatStructured\u0153,\u0153id\u0153:\u0153GChatStructured-p3gif\u0153,\u0153name\u0153:\u0153output\u0153,\u0153output_types\u0153:[\u0153Data\u0153]}", "target": "ParserComponent-3ZCGm", "targetHandle": "{\u0153fieldName\u0153:\u0153input_data\u0153,\u0153id\u0153:\u0153ParserComponent-3ZCGm\u0153,\u0153inputTypes\u0153:[\u0153DataFrame\u0153,\u0153Data\u0153],\u0153type\u0153:\u0153other\u0153}", "data": {"targetHandle": {"fieldName": "input_data", "id": "ParserComponent-3ZCGm", "inputTypes": ["DataFrame", "Data"], "type": "other"}, "sourceHandle": {"dataType": "GChatStructured", "id": "GChatStructured-p3gif", "name": "output", "output_types": ["Data"]}}, "id": "xy-edge__GChatStructured-p3gif{\u0153dataType\u0153:\u0153GChatStructured\u0153,\u0153id\u0153:\u0153GChatStructured-p3gif\u0153,\u0153name\u0153:\u0153output\u0153,\u0153output_types\u0153:[\u0153Data\u0153]}-ParserComponent-3ZCGm{\u0153fieldName\u0153:\u0153input_data\u0153,\u0153id\u0153:\u0153ParserComponent-3ZCGm\u0153,\u0153inputTypes\u0153:[\u0153DataFrame\u0153,\u0153Data\u0153],\u0153type\u0153:\u0153other\u0153}", "selected": false, "animated": false, "className": ""}], "viewport": {"x": 2198.037033351814, "y": -1526.9285891020052, "zoom": 1.1296881875787816}}, "is_component": false, "updated_at": "2025-10-10T22:57:22+00:00", "webhook": false, "endpoint_name": null, "tags": [], "locked": false, "mcp_enabled": true, "action_name": "get_historical_rate", "action_description": "", "access_type": "PRIVATE", "id": "6f5e21fe-07da-45b9-ae17-8ed1e867c775", "user_id": "69cd4506-ab8f-481e-ac27-e150c55311bf", "folder_id": "3ebb98ec-78dc-4a7b-ac61-f29e49862381"}